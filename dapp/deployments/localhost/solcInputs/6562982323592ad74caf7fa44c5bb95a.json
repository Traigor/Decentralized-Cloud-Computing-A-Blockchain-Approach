{
  "language": "Solidity",
  "sources": {
    "contracts/TasksManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract TasksManager {\n\n    address private immutable owner; \n\n    enum TaskState {\n        Created,\n        Cancelled, //to be cut\n        Active,\n        Completed,\n        Invalid //to be cut\n    }\n\n    enum PaymentState {\n        Initialized,\n        Pending,\n        Completed //to be cut\n    }\n\n\n    struct Task {\n        address payable provider;\n        address payable client; \n        uint price;\n        uint providerCollateral;\n        uint clientCollateral; //maybe to be cut if createTask is not called by client\n        uint payment;\n        uint deadline;\n        uint duration;\n        uint activationTime;\n        uint timeResultProvided;\n        uint timeResultReceived;\n        TaskState taskState;\n        PaymentState paymentState;\n        string code;\n        bytes32 clientVerification;\n        string providerVerification;\n    }\n\n    struct providerRating {\n        uint upVotes;\n        uint downVotes;\n    }\n\n    mapping (bytes32 => Task) private tasks;\n    mapping(address => providerRating) private performance;\n\n    //Events\n    event TaskCreated(bytes32 taskID);\n    event TaskActivated(bytes32 taskID);\n    event TaskCompleted(bytes32 taskID);\n    event TaskCancelled(bytes32 taskID);\n    event TaskInvalidated(bytes32 taskID);\n    event PaymentPending(bytes32 taskID, uint payment);\n    event PaymentCompleted(bytes32 taskID);\n    event TransferMade(address Address, uint Amount);\n    event ProviderUpvoted(address provider, bytes32 task);\n    event ProviderDownvoted(address provider, bytes32 task);\n    event TaskRegistered(bytes32 task);\n    event TaskUnregistered(bytes32 task);\n\n    //Modifiers\n\n    modifier ownerOnly() {\n        require(\n            msg.sender == owner,\n            \"Method can be called only by owner.\"\n        );\n        _;\n    }\n\n    modifier clientOnly(bytes32 _taskID) {\n        require(\n            msg.sender == tasks[_taskID].client,\n            \"Method can be called only by client.\"\n        );\n        _;\n    }\n\n    modifier providerOnly(bytes32 _taskID) {\n        require(\n            msg.sender == tasks[_taskID].provider,\n            \"Method can be called only by provider.\"\n        );\n        _;\n    }\n\n    modifier inTaskState(bytes32 _taskID,TaskState _taskState) {\n        require(\n            tasks[_taskID].taskState == _taskState,\n            \"Invalid TaskState.\"\n        );\n        _;\n    }\n\n    modifier inPaymentState(bytes32 _taskID,PaymentState _paymentState) {\n        require(\n            tasks[_taskID].paymentState == _paymentState,\n            \"Invalid PaymentState.\"\n        );\n        _;\n    }\n\n    modifier requiresValue(uint amount) {\n        require(\n            msg.value == amount,\n            \"Value sent is not the expected\"\n        );\n        _;\n    }\n\n    modifier registeredTaskOnly(bytes32 _taskID) {\n        require(\n            isRegistered(_taskID),\n            \"Task must be registered\"\n        );\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    //owner only or by auction contract or by client\n    function createTask(\n        bytes32 _taskID, \n        address payable _client, //if called by client, this is msg.sender\n        address payable _provider,\n        uint _price,\n        uint _providerCollateral,\n        uint _deadline,\n        bytes32 _clientVerification\n    ) \n    public\n    {\n        tasks[_taskID].client = _client;\n        tasks[_taskID].provider = _provider;\n        tasks[_taskID].price = _price;\n        tasks[_taskID].providerCollateral = _providerCollateral;\n        tasks[_taskID].deadline = _deadline;\n        tasks[_taskID].clientVerification = _clientVerification;\n        tasks[_taskID].taskState = TaskState.Created;\n        tasks[_taskID].paymentState = PaymentState.Initialized;\n        emit TaskCreated(_taskID);\n        emit TaskRegistered(_taskID);\n    }\n\n    //Cancel\n    //TaskState -> Cancel\n    //refunds payment to client\n    //can be called only by client and only if contract hasnt been activated by provider\n\n    function cancelTask(bytes32 _taskID) public clientOnly(_taskID) inTaskState(_taskID,TaskState.Created) \n    {\n        tasks[_taskID].taskState = TaskState.Cancelled;\n        tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral);\n        emit TransferMade(tasks[_taskID].client,tasks[_taskID].clientCollateral);\n        delete(tasks[_taskID]);\n        emit TaskCancelled(_taskID);\n        emit TaskUnregistered(_taskID);\n    }\n\n    function invalidateTask(bytes32 _taskID) public  clientOnly(_taskID) inTaskState(_taskID, TaskState.Active) \n    {\n        require(\n            (block.timestamp > tasks[_taskID].activationTime + tasks[_taskID].deadline),\n            \"Time has not expired.\"\n        );\n        tasks[_taskID].taskState = TaskState.Invalid;\n  \n        tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n        emit TransferMade(tasks[_taskID].client, tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n        delete(tasks[_taskID]);\n        emit TaskInvalidated(_taskID);\n        emit TaskUnregistered(_taskID);\n    }\n\n    // Activate\n    // TaskState -> Activated\n    // can be called only by provider to start the process\n\n    function activateTask(bytes32 _taskID) public payable providerOnly(_taskID) requiresValue(tasks[_taskID].providerCollateral) inTaskState(_taskID,TaskState.Created) registeredTaskOnly(_taskID)\n    {\n        tasks[_taskID].activationTime = block.timestamp;\n        tasks[_taskID].taskState = TaskState.Active;\n        emit TaskActivated(_taskID);\n    }\n\n    // Complete\n    // TaskState -> Completed\n    // can be called only by provider when the computation is over\n\n    function completeTask(bytes32 _taskID,string memory ver, uint _timeReceivedProvider) public providerOnly(_taskID) inTaskState(_taskID,TaskState.Active) \n    {\n        tasks[_taskID].providerVerification = ver;   \n        tasks[_taskID].timeResultReceived = block.timestamp;\n        tasks[_taskID].timeResultProvided = _timeReceivedProvider;\n        // payable(msg.sender).transfer(address(this).balance);\n        if (InTime(_taskID) && ProviderTime(_taskID) && CorrectVerification(_taskID)){\n            tasks[_taskID].duration = tasks[_taskID].timeResultProvided - tasks[_taskID].activationTime;\n            tasks[_taskID].payment = tasks[_taskID].price * tasks[_taskID].duration;\n            if (tasks[_taskID].payment <= tasks[_taskID].clientCollateral) {\n                tasks[_taskID].provider.transfer(tasks[_taskID].payment+tasks[_taskID].providerCollateral);\n                emit TransferMade(tasks[_taskID].provider, tasks[_taskID].payment+tasks[_taskID].providerCollateral);\n                tasks[_taskID].client.transfer(tasks[_taskID].payment-tasks[_taskID].clientCollateral);\n                //  emit TransferMade(tasks[_taskID].client, tasks[_taskID].payment-tasks[_taskID].clientCollateral);\n                emit TransferMade(tasks[_taskID].client, tasks[_taskID].duration);\n                tasks[_taskID].paymentState = PaymentState.Completed;\n                emit PaymentCompleted(_taskID);\n                //send result of computation\n                \n            }\n            else {\n                tasks[_taskID].provider.transfer(tasks[_taskID].clientCollateral+tasks[_taskID].providerCollateral);\n                emit TransferMade(tasks[_taskID].provider, tasks[_taskID].clientCollateral+tasks[_taskID].providerCollateral);    \n                tasks[_taskID].paymentState = PaymentState.Pending;\n                emit PaymentPending(_taskID,tasks[_taskID].payment-tasks[_taskID].clientCollateral);\n            }\n            performance[tasks[_taskID].provider].upVotes += 1;\n            emit ProviderUpvoted(tasks[_taskID].provider,_taskID);\n        }\n        else {\n            tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            emit TransferMade(tasks[_taskID].client, tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            performance[tasks[_taskID].provider].downVotes += 1;\n            emit ProviderDownvoted(tasks[_taskID].provider,_taskID);\n        }\n        tasks[_taskID].taskState = TaskState.Completed;\n        if (tasks[_taskID].paymentState == PaymentState.Completed){\n            delete(tasks[_taskID]);\n        }\n        emit TaskCompleted(_taskID);\n        emit TaskUnregistered(_taskID);\n    }\n    //not tested the occasion of client collateral because it is not decided yet if\n    //createTask will be called by client, owner or the auction contract\n\n    function completePayment(bytes32 _taskID) public payable clientOnly(_taskID) inTaskState(_taskID,TaskState.Completed) inPaymentState(_taskID,PaymentState.Pending) requiresValue(tasks[_taskID].payment-tasks[_taskID].clientCollateral) {\n        require (tasks[_taskID].paymentState == PaymentState.Pending, \"Payment not needed\");\n        tasks[_taskID].provider.transfer(msg.value);\n        emit TransferMade(tasks[_taskID].provider, tasks[_taskID].payment-tasks[_taskID].clientCollateral);\n        tasks[_taskID].paymentState = PaymentState.Completed;\n        emit PaymentCompleted(_taskID);\n        delete(tasks[_taskID]);\n        //send or emit result of computation\n    }\n\n    function getTask(bytes32 _taskID) public view returns (Task memory) {\n        return tasks[_taskID];\n    }\n\n    //Setters\n\n\n    //code to be in constructor in createTask\n    // function setCode(bytes32 _taskID, string memory _code) public{\n    //     tasks[_taskID].code = _code;\n    // }\n\n    //Functions -> Private/internal\n    function InTime(bytes32 _taskID) public view returns (bool){\n        return (tasks[_taskID].timeResultReceived <= tasks[_taskID].activationTime + tasks[_taskID].deadline);  //first argument may be deleted\n    }\n\n    function ProviderTime(bytes32 _taskID) public view returns (bool) {\n        return (tasks[_taskID].timeResultReceived <= tasks[_taskID].timeResultProvided + 60); //gives 60 sec to provider to send the results\n    }\n\n    function CorrectVerification(bytes32 _taskID) public view returns (bool){\n        return (tasks[_taskID].clientVerification == keccak256(abi.encodePacked(tasks[_taskID].providerVerification)));\n    }\n\n    function isRegistered(bytes32 _taskID) public view returns (bool) {\n        return (tasks[_taskID].client != address(0));\n    }\n\n    function getPerformance(address provider) public view returns (providerRating memory) {\n        return performance[provider];\n        // tuple: upVotes, downVotes\n    }\n\n    //Getters - to be deleted\n    function getActivationTime(bytes32 _taskID) public view returns (uint)\n    {\n        return tasks[_taskID].activationTime;\n    }\n\n    // function getCode() public view returns (string memory){\n    //     return code;\n    // }\n\n    // TaskState: Created->0, Cancelled->1, Active->2, Completed->3, Invalid->4\n    function getTaskState(bytes32 _taskID) public view returns (TaskState)\n    {\n        return tasks[_taskID].taskState;\n    }\n\n    // PaymentState: Initiliazed->0, Pending->1, Completed->2\n    function getPaymentState(bytes32 _taskID) public view returns (PaymentState)\n    {\n        return tasks[_taskID].paymentState;\n    }\n\n    function getPayment(bytes32 _taskID) public view returns (uint)\n    {\n        return tasks[_taskID].payment;\n    }\n\n    function getProviderCollateral(bytes32 _taskID) public view returns (uint)\n    {\n        return tasks[_taskID].providerCollateral;\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    // Fallback Function\n    fallback() external payable{\n        revert();\n    }\n\n    receive() external payable {\n        revert(\"bad call\");\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}