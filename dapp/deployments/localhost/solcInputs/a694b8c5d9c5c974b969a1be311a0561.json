{
  "language": "Solidity",
  "sources": {
    "contracts/Registry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Registry {\n\n    address private immutable owner; \n\n    struct providerRating {\n        uint upVotes;\n        uint downVotes;\n    }\n\n    mapping(address => providerRating) private performance;\n    mapping (bytes32 => bool) private registeredTask;    // it could also be only task address => bool\n\n    event ProviderUpvoted(address provider, address task);\n    event ProviderDownvoted(address provider, address task);\n    event TaskRegistered(address task);\n    event TaskUnregistered(address task);\n\n    modifier ownerOnly() {\n        require(\n            msg.sender == owner,\n            \"Method can be called only by owner.\"\n        );\n        _;\n    }\n\n    modifier registeredTaskOnly() {\n        require(\n            isRegistered(),\n            \"Task must be registered\"\n        );\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    function registerTask(address task) ownerOnly public {\n      bytes32 hash = keccak256(abi.encodePacked(task));\n      registeredTask[hash] = true;\n      emit TaskRegistered(task);\n    }\n\n    function unregisterTask() registeredTaskOnly() public {\n        bytes32 hash = keccak256(abi.encodePacked(msg.sender));\n        delete registeredTask[hash];\n        emit TaskUnregistered(msg.sender);\n    }\n\n    function isRegistered() public view returns (bool) {\n        bytes32 hash = keccak256(abi.encodePacked(msg.sender));\n        return registeredTask[hash];\n    }\n\n    function upVote(address provider) registeredTaskOnly public { \n    // function upVote(address provider) external {\n        performance[provider].upVotes += 1;\n        // performance[provider].upVotes += 10; //for tests\n        emit ProviderUpvoted(provider,msg.sender);\n    }\n\n    function downVote(address provider) registeredTaskOnly external {\n    // function downVote(address provider) external {\n        performance[provider].downVotes += 1;\n        // performance[provider].downVotes += 10; //for tests\n        emit ProviderDownvoted(provider,msg.sender);\n    }\n\n    function getPerformance(address provider) public view returns (providerRating memory) {\n        return performance[provider];\n        // tuple: upVotes, downVotes\n    }\n\n    // could be calculated in the app\n    // function getScore(address provider) public view returns (uint) {\n    //    return confidence(performance[provider].upVotes,performance[provider].downVotes);\n    // }\n\n    // function confidence(uint ups, uint downs) private pure returns (uint) {\n    //     if (ups + downs == 0) \n    //         return 0;\n\n    //     //precision is 3 decimal digits\n    //     uint n = ups + downs;\n\n    //     uint z = 1960;  //z-score for 95% two-sided confidence = 1.96\n    //     // uint z = 1645;  //z-score for 90% two-sided confidence = 1.645\n    //     // uint z = 1440; //-score for 85% two-sided confidence = 1.44\n    //     // uint z = 1282; //z-score for 80% two sided confidence = 1.282\n        \n    //     uint p = divider(ups,n,3);\n    //     uint left = p + divider(1,2*n,3)*z*z/1000000; \n    //     uint right = z * sqrt(divider(p*(1000-p),n,0) + divider(z*z,4*n*n,0))/1000; \n    //     uint denominator = 1000 + divider(1,n,3)*z*z/1000000;\n\n    //     return divider(left-right, denominator, 3);\n    // }\n    \n    // function divider(uint numerator, uint denominator, uint precision) private pure returns(uint) {\n    //     return numerator*(uint(10)**uint(precision))/denominator;\n    // }\n\n    // //babylonian method\n    // function sqrt(uint x) private pure returns (uint) {\n    //     uint z = divider(x+1,2,0); \n    //     uint y = x;\n    //     uint temp;\n    //     while (z < y) {\n    //         y = z;\n    //         temp = divider(x,z,0);\n    //         z = divider(temp+z,2,0);\n    //     }\n    //     return uint(y);\n    // }\n\n\n    // Fallback Function\n    fallback() external payable{\n        revert();\n    }\n\n    receive() external payable {\n        revert(\"bad call\");\n    }\n}"
    },
    "contracts/Task.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./Registry.sol\";\n\ncontract Task {\n\n    enum TaskState {\n        Created,\n        Cancelled,\n        Active,\n        Completed,\n        Invalid\n    }\n\n    enum PaymentState {\n        Initialized,\n        Pending,\n        Completed\n    }\n\n    address payable private immutable provider;\n    address payable private immutable client;\n    bytes32 private immutable taskID; //by auction contract  \n\n    Registry private registry; //to be deleted later\n    // Registry private immutable registry = <address>\n    \n    uint private immutable price;   //can be float at front-end, payment per sec of execution\n    uint private providerCollateral;   //can be float at front-end\n    uint private clientCollateral;\n    uint private payment;\n    uint private deadline;\n    uint private duration;  //contract duration, in sec\n    \n    uint private activationTime;   //contract activation date, in sec since epoch\n    uint private timeResultProvided;     //time of result given by provider, in sec since epoch\n    uint private timeResultReceived;    //time of received result, in sec since epoch   \n\n    TaskState private taskState;   //taskState of contract\n    PaymentState private paymentState;\n\n    string code;   //string for ipfs address \n\n    bytes32 private immutable clientVerification;\n    string private providerVerification;\n\n\n    //Events \n    //taskID to be deleted\n    event TaskCreated(address task);\n    event TaskActivated(bytes32 taskID);\n    event TaskCompleted(bytes32 taskID);\n    event TaskCancelled(bytes32 taskID);\n    event TaskInvalidated(bytes32 taskID);\n    event PaymentPending(bytes32 taskID, uint payment);\n    event PaymentCompleted(bytes32 taskID);\n    event TransferMade(address Address, uint Amount);\n\n    //Modifiers \n    modifier clientOnly() {\n        require(\n            msg.sender == client,\n            \"Method can be called only by client.\"\n        );\n        _;\n    }\n\n    modifier providerOnly() {\n        require(\n            msg.sender == provider,\n            \"Method can be called only by provider.\"\n        );\n        _;\n    }\n\n    modifier inTaskState(TaskState _taskState) {\n        require(\n            taskState == _taskState,\n            \"Invalid TaskState.\"\n        );\n        _;\n    }\n\n    modifier inPaymentState(PaymentState _paymentState) {\n        require(\n            paymentState == _paymentState,\n            \"Invalid PaymentState.\"\n        );\n        _;\n    }\n\n    modifier requiresBalance(uint amount) {\n        require(\n            address(this).balance >= amount,\n            \"Not enough balance\"\n        );\n        _;\n    }\n\n    modifier requiresValue(uint amount) {\n        require(\n            msg.value == amount,\n            \"Value sent is not the expected\"\n        );\n        _;\n    }\n\n    modifier registeredTaskOnly() {\n        require(\n            registry.isRegistered(),\n            \"Task must be registered\"\n        );\n        _;\n    }\n\n\n    //Constructor ,TasksRegistry will be deleted\n    constructor(\n        bytes32 _taskID,\n        address payable _client,\n        address payable _provider,\n        uint _price,\n        uint _providerCollateral,\n        uint _deadline,\n        bytes32  _clientVerification,\n        Registry _registry \n    )\n    payable\n    {\n        taskID = _taskID;\n        client = _client;\n        provider = _provider;\n        price = _price;\n        clientCollateral = msg.value;\n        providerCollateral = _providerCollateral;\n        deadline = _deadline; \n        clientVerification = _clientVerification;\n        taskState = TaskState.Created;\n        paymentState = PaymentState.Initialized; \n        registry = _registry;\n        emit TaskCreated(address(this));\n    }\n\n    // TaskState functions to be called by smart contract or client/provider? \n\n    //Cancel\n    //TaskState -> Cancel\n    //refunds payment to client\n    //can be called only by client and only if contract hasnt been activated by provider\n\n    // - no requiresClient so that it can be tested\n    function cancelTask() public clientOnly inTaskState(TaskState.Created) requiresBalance(clientCollateral)\n    // function cancelTask() public inTaskState(TaskState.Created) requiresBalance(clientCollateral)\n    {\n        taskState = TaskState.Cancelled;\n \n        client.transfer(clientCollateral);\n        emit TransferMade(client,clientCollateral);\n        registry.unregisterTask();\n        emit TaskCancelled(taskID);\n    }\n\n    //Invalidate\n    ///TaskState -> Invalid\n    //can be called only by client and only if contract is activated  \n    //if time has passed and the task is not comleted by the provider\n    //transfers payment and collateral to client\n    \n    // - no requiresClient so that it can be tested\n    function invalidateTask() public  clientOnly inTaskState(TaskState.Active) requiresBalance(clientCollateral + providerCollateral)\n    // function invalidateTask() public inTaskState(TaskState.Active) requiresBalance(clientCollateral + providerCollateral) \n    {\n        require(\n            (block.timestamp >  activationTime + deadline),\n            \"Time has not expired.\"\n        );\n        taskState = TaskState.Invalid;\n  \n        client.transfer(clientCollateral + providerCollateral);\n        emit TransferMade(client, clientCollateral + providerCollateral);\n        registry.unregisterTask();\n        emit TaskInvalidated(taskID);\n    }\n\n    // Activate\n    // TaskState -> Activated\n    // can be called only by provider to start the process\n\n    // - no requiresProvider so that it can be tested\n    function activateTask() public payable providerOnly requiresValue(providerCollateral) inTaskState(TaskState.Created) requiresBalance(clientCollateral + providerCollateral) registeredTaskOnly\n    // function activateTask() public payable requiresValue(providerCollateral) inTaskState(TaskState.Created) requiresBalance(clientCollateral + providerCollateral) registeredTaskOnly\n    {\n        activationTime = block.timestamp;\n        taskState = TaskState.Active;\n        emit TaskActivated(taskID);\n    }\n\n\n    // Complete\n    // TaskState -> Completed\n    // can be called only by provider when the computation is over\n\n    // - no requiresProvider so that it can be tested\n    function completeTask() public providerOnly inTaskState(TaskState.Active) requiresBalance(clientCollateral + providerCollateral)\n    // function completeTask() public inTaskState(TaskState.Active) requiresBalance(clientCollateral + providerCollateral)\n    {\n        // payable(msg.sender).transfer(address(this).balance);\n        if (InTime() && ProviderTime() && CorrectVerification()){\n            duration = timeResultProvided - activationTime;\n            payment = price * duration;\n            if (payment <= clientCollateral) {\n                provider.transfer(payment+providerCollateral);\n                emit TransferMade(provider, payment+providerCollateral);\n                client.transfer(payment-clientCollateral);\n                emit TransferMade(client, payment-clientCollateral);\n                paymentState = PaymentState.Completed;\n                emit PaymentCompleted(taskID);\n                //send result of computation\n                \n            }\n            else {\n                provider.transfer(clientCollateral+providerCollateral);\n                emit TransferMade(provider, clientCollateral+providerCollateral);\n                paymentState = PaymentState.Pending;\n                emit PaymentPending(taskID,payment-clientCollateral);\n            }\n            registry.upVote(provider);\n        }\n        else {\n            client.transfer(clientCollateral + providerCollateral);\n            emit TransferMade(client, clientCollateral + providerCollateral);\n            registry.downVote(provider);\n        }\n        taskState = TaskState.Completed;\n        registry.unregisterTask();\n        emit TaskCompleted(taskID);\n    }\n\n    function completePayment() public payable clientOnly inTaskState(TaskState.Completed) inPaymentState(PaymentState.Pending) requiresValue(payment-clientCollateral) {\n    // function completePayment() public payable inTaskState(TaskState.Completed) requiresValue(payment - clientCollateral) {\n        require (paymentState == PaymentState.Pending, \"Payment not needed\");\n        provider.transfer(msg.value);\n        emit TransferMade(provider, payment-clientCollateral); \n        paymentState = PaymentState.Completed;\n        emit PaymentCompleted(taskID);\n        //send or emit result of computation\n    }\n    \n    //Setters\n    //to be inside completeTask\n    function receiveResults(string memory ver, uint _timeReceivedProvider) public {\n        providerVerification = ver;   \n        timeResultReceived = block.timestamp;\n        timeResultProvided = _timeReceivedProvider;\n    }\n\n    //code to be in constructor\n    function setCode(string memory _code) public{\n        code = _code;\n    }\n\n    //Getters - to be deleted\n    function getActivationTime() public view returns (uint)\n    {\n        return activationTime;\n    }\n\n    // function getCode() public view returns (string memory){\n    //     return code;\n    // }\n\n    // TaskState: Created->0, Cancelled->1, Active->2, Completed->3, Invalid->4\n    function getTaskState() public view returns (TaskState)\n    {\n        return taskState;\n    }\n\n    // PaymentState: Initiliazed->0, Pending->1, Completed->2\n    function getPaymentState() public view returns (PaymentState)\n    {\n        return paymentState;\n    }\n\n    function getPayment() public view returns (uint)\n    {\n        return payment;\n    }\n\n    function getProviderCollateral() public view returns (uint)\n    {\n        return providerCollateral;\n    }\n\n    //Functions -> Private/internal\n    function InTime() public view returns (bool){\n        return (timeResultReceived <= activationTime + deadline);  //first argument may be deleted\n    }\n\n    function ProviderTime() public view returns (bool) {\n        return (timeResultReceived <= timeResultProvided + 60); //gives 60 sec to provider to send the results\n    }\n\n    function CorrectVerification() public view returns (bool){\n        return (clientVerification == keccak256(abi.encodePacked(providerVerification)));\n    }\n\n    // Fallback Function\n    fallback() external payable{\n        revert();\n    }\n\n    receive() external payable {\n        revert(\"bad call\");\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}