{
  "language": "Solidity",
  "sources": {
    "contracts/TasksManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract TasksManager {\n\n    address private immutable owner; \n\n    enum TaskState {\n        Created,\n        Cancelled, \n        Active,\n        CompletedSuccessfully,\n        CompletedUnsuccessfully,\n        Invalid, \n        ResultsReceived\n    }\n\n    enum PaymentState {\n        Initialized,\n        Pending,\n        Completed \n    }\n\n    struct Task {\n        address payable client; \n        address payable provider;\n        uint providerCollateral;\n        uint clientCollateral; \n        uint deadline;\n        uint price;\n        uint duration;\n        uint cost;       \n        uint activationTime;\n        uint timeResultProvided;\n        uint timeResultReceived;\n        string computationCode;\n        string verificationCode;\n        string results;\n        bytes32 clientVerification;\n        TaskState taskState;\n        PaymentState paymentState;\n    }\n\n    struct providerRating {\n        uint upVotes;\n        uint downVotes;\n    }\n\n    mapping (bytes32 => Task) private tasks;\n    mapping(address => providerRating) private performance;\n\n    //Events\n    event TaskCreated(bytes32 taskID);\n    event TaskActivated(bytes32 taskID);\n    event TaskCompletedSuccessfully(bytes32 taskID);\n    event TaskCompletedUnsuccessfully(bytes32 taskID);\n    event TaskReceivedResults(bytes32 taskID);\n    event TaskCancelled(bytes32 taskID);\n    event TaskInvalidated(bytes32 taskID);\n    event PaymentPending(bytes32 taskID, uint payment);\n    event PaymentCompleted(bytes32 taskID);\n    event TransferMadeToClient(address client, uint amount);\n    event TransferMadeToProvider(address provider, uint amount);\n    event ProviderUpvoted(address provider, bytes32 taskID);\n    event ProviderDownvoted(address provider, bytes32 taskID);\n    event TaskDeleted(bytes32 taskID);\n\n    //Modifiers\n\n    modifier ownerOnly() {\n        require(\n            msg.sender == owner,\n            \"Method can be called only by owner.\"\n        );\n        _;\n    }\n\n    modifier clientOnly(bytes32 _taskID) {\n        require(\n            msg.sender == tasks[_taskID].client,\n            \"Method can be called only by client.\"\n        );\n        _;\n    }\n\n    modifier providerOnly(bytes32 _taskID) {\n        require(\n            msg.sender == tasks[_taskID].provider,\n            \"Method can be called only by provider.\"\n        );\n        _;\n    }\n\n    modifier clientOrProviderOnly(bytes32 _taskID) {\n        require(\n            (msg.sender == tasks[_taskID].client) || (msg.sender == tasks[_taskID].provider) || (msg.sender == owner),\n            \"Method can be called only by client, provider or the owner.\"\n        );\n        _;\n    }\n\n    modifier inTaskState(bytes32 _taskID,TaskState _taskState) {\n        require(\n            tasks[_taskID].taskState == _taskState,\n            \"Invalid TaskState.\"\n        );\n        _;\n    }\n\n    modifier inPaymentState(bytes32 _taskID,PaymentState _paymentState) {\n        require(\n            tasks[_taskID].paymentState == _paymentState,\n            \"Invalid PaymentState.\"\n        );\n        _;\n    }\n\n    modifier requiresValue(uint amount) {\n        require(\n            msg.value == amount,\n            \"Value sent is not the expected\"\n        );\n        _;\n    }\n\n    modifier registeredTaskOnly(bytes32 _taskID) {\n        require(\n            isRegistered(_taskID),\n            \"Task must be registered\"\n        );\n        _;\n    }\n\n    modifier notRegisteredTaskOnly(bytes32 _taskID) {\n        require(\n            !isRegistered(_taskID),\n            \"Task already exists\"\n        );\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    //called by client, client = msg.sender\n    function createTask(\n        bytes32 _taskID, \n        address payable _provider,\n        uint _price,\n        uint _deadline,\n        bytes32 _clientVerification,\n        string memory _verificationCode,\n        string memory _computationCode\n    ) public payable notRegisteredTaskOnly(_taskID)\n    {\n        require (msg.value >= _price * 2, \"Client collateral is not enough\");\n        tasks[_taskID].client = payable (msg.sender);\n        tasks[_taskID].clientCollateral = msg.value;\n        tasks[_taskID].provider = _provider;\n        tasks[_taskID].providerCollateral = _price * 10;\n        tasks[_taskID].price = _price;\n        tasks[_taskID].deadline = _deadline;\n        tasks[_taskID].clientVerification = _clientVerification;\n        tasks[_taskID].verificationCode = _verificationCode;\n        tasks[_taskID].computationCode = _computationCode;\n        tasks[_taskID].taskState = TaskState.Created;\n        tasks[_taskID].paymentState = PaymentState.Initialized;\n        emit TaskCreated(_taskID);\n    }\n\n    //Cancel\n    //TaskState -> Cancel\n    //refunds payment to client\n    //can be called only by client and only if contract hasnt been activated by provider\n\n    function cancelTask(bytes32 _taskID) public clientOnly(_taskID) inTaskState(_taskID,TaskState.Created) \n    {\n        tasks[_taskID].taskState = TaskState.Cancelled;\n        tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral);\n        emit TransferMadeToClient(tasks[_taskID].client,tasks[_taskID].clientCollateral);\n        emit TaskCancelled(_taskID);\n        // deleteTask(_taskID);\n    }\n\n    function invalidateTask(bytes32 _taskID) public  clientOnly(_taskID) inTaskState(_taskID, TaskState.Active) \n    {\n        require(\n            (block.timestamp > tasks[_taskID].activationTime + tasks[_taskID].deadline),\n            \"Time has not expired.\"\n        );\n        tasks[_taskID].taskState = TaskState.Invalid;\n  \n        tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n        emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n        emit TaskInvalidated(_taskID);\n        // deleteTask(_taskID);\n    }\n\n    // Activate\n    // TaskState -> Activated\n    // can be called only by provider to start the process\n\n    function activateTask(bytes32 _taskID) public payable providerOnly(_taskID) inTaskState(_taskID,TaskState.Created) registeredTaskOnly(_taskID)\n    {\n        require (msg.value >= tasks[_taskID].providerCollateral, \"Provider collateral is not enough\");\n        tasks[_taskID].activationTime = block.timestamp;\n        tasks[_taskID].providerCollateral = msg.value;\n        tasks[_taskID].taskState = TaskState.Active;\n        emit TaskActivated(_taskID);\n    }\n\n    // Complete\n    // TaskState -> Completed\n    // can be called only by provider when the computation is over\n\n    //called by docker container\n    function completeTask(bytes32 _taskID,string memory ver,  uint _duration, uint _timeReceivedProvider) public providerOnly(_taskID) inTaskState(_taskID,TaskState.Active) \n    {\n        tasks[_taskID].timeResultProvided = _timeReceivedProvider;\n        tasks[_taskID].duration = _duration;\n        if (InTime(_taskID) && CorrectVerification(_taskID, ver)){\n            tasks[_taskID].cost = tasks[_taskID].price * tasks[_taskID].duration;\n            tasks[_taskID].taskState = TaskState.CompletedSuccessfully;\n            emit TaskCompletedSuccessfully(_taskID);\n        }\n        else {\n            tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            performance[tasks[_taskID].provider].downVotes += 1;\n            emit ProviderDownvoted(tasks[_taskID].provider,_taskID);\n            tasks[_taskID].taskState = TaskState.CompletedUnsuccessfully;\n            emit TaskCompletedUnsuccessfully(_taskID);\n            // deleteTask(_taskID);\n        }\n    }\n\n\n    //called by provider\n    function receiveResults(bytes32 _taskID, string memory _results) public providerOnly(_taskID) inTaskState(_taskID,TaskState.CompletedSuccessfully) inPaymentState(_taskID,PaymentState.Initialized){\n        tasks[_taskID].timeResultReceived = block.timestamp;\n        tasks[_taskID].results = _results;\n        if (ProviderTime(_taskID)){\n            if (tasks[_taskID].cost <= tasks[_taskID].clientCollateral) {\n                tasks[_taskID].provider.transfer(tasks[_taskID].cost + tasks[_taskID].providerCollateral);\n                emit TransferMadeToProvider(tasks[_taskID].provider, tasks[_taskID].cost + tasks[_taskID].providerCollateral);\n                tasks[_taskID].client.transfer(tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n                emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n                tasks[_taskID].paymentState = PaymentState.Completed;\n                emit PaymentCompleted(_taskID);                \n            }\n            else {\n                tasks[_taskID].provider.transfer(tasks[_taskID].clientCollateral+tasks[_taskID].providerCollateral);\n                emit TransferMadeToProvider(tasks[_taskID].provider, tasks[_taskID].clientCollateral+tasks[_taskID].providerCollateral);\n                tasks[_taskID].paymentState = PaymentState.Pending;\n                emit PaymentPending(_taskID,tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n            }\n            performance[tasks[_taskID].provider].upVotes += 1;\n            emit ProviderUpvoted(tasks[_taskID].provider,_taskID);\n        }\n        else {\n            tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            performance[tasks[_taskID].provider].downVotes += 1;\n            emit ProviderDownvoted(tasks[_taskID].provider,_taskID);\n        }\n        tasks[_taskID].taskState = TaskState.ResultsReceived;\n        emit TaskReceivedResults(_taskID);\n    }\n\n\n    function completePayment(bytes32 _taskID) public payable clientOnly(_taskID) inTaskState(_taskID,TaskState.ResultsReceived) inPaymentState(_taskID,PaymentState.Pending) requiresValue(tasks[_taskID].cost - tasks[_taskID].clientCollateral) {\n        require (tasks[_taskID].paymentState == PaymentState.Pending, \"Payment not needed\");\n        tasks[_taskID].provider.transfer(msg.value);\n        emit TransferMadeToProvider(tasks[_taskID].provider, tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n        tasks[_taskID].paymentState = PaymentState.Completed;\n        emit PaymentCompleted(_taskID);\n    }\n\n\n    function deleteTask(bytes32 _taskID) public registeredTaskOnly(_taskID) {\n        delete(tasks[_taskID]);\n        emit TaskDeleted(_taskID);\n    }\n\n    //Functions -> Private/internal\n    function InTime(bytes32 _taskID) private view returns (bool){\n        return (tasks[_taskID].timeResultProvided <= tasks[_taskID].activationTime + tasks[_taskID].deadline) && (tasks[_taskID].duration <= tasks[_taskID].deadline);  \n    }\n\n    function ProviderTime(bytes32 _taskID) private view returns (bool) {\n        return (tasks[_taskID].timeResultReceived <= tasks[_taskID].timeResultProvided + 60) && (tasks[_taskID].timeResultReceived >= tasks[_taskID].timeResultProvided) && (tasks[_taskID].timeResultReceived >= tasks[_taskID].activationTime) && (tasks[_taskID].timeResultProvided >= tasks[_taskID].activationTime); //gives 60 sec to provider to send the results, time received must be greater than time provided\n    }\n\n    function CorrectVerification(bytes32 _taskID, string memory ver) private view returns (bool){\n        return (tasks[_taskID].clientVerification == keccak256(abi.encodePacked(ver)));\n    }\n\n    function isRegistered(bytes32 _taskID) public view returns (bool) {\n        return (tasks[_taskID].client != address(0));\n    }\n\n    function getPerformance(address provider) public view returns (providerRating memory) {\n        return performance[provider];\n        // tuple: upVotes, downVotes\n    }\n\n    //Getters - some to be deleted\n    function getActivationTime(bytes32 _taskID) public view returns (uint)\n    {\n        return tasks[_taskID].activationTime;\n    }\n\n    function getResults(bytes32 _taskID) public clientOnly(_taskID) inTaskState(_taskID,TaskState.ResultsReceived) inPaymentState(_taskID,PaymentState.Completed) view returns (string memory)  {\n        return tasks[_taskID].results;\n    }\n\n    function getTaskState(bytes32 _taskID) public clientOrProviderOnly(_taskID) view returns (string memory)\n    {\n        string memory ret = \"\";\n        if (tasks[_taskID].taskState == TaskState.Created) \n            ret = \"Created\";\n        else if (tasks[_taskID].taskState == TaskState.Cancelled)\n            ret = \"Cancelled\";\n        else if (tasks[_taskID].taskState == TaskState.Active)\n            ret = \"Active\";\n        else if (tasks[_taskID].taskState == TaskState.CompletedSuccessfully)\n            ret = \"CompletedSuccessfully\";\n        else if (tasks[_taskID].taskState == TaskState.CompletedUnsuccessfully)\n            ret = \"CompletedUnsuccessfully\";  \n        else if (tasks[_taskID].taskState == TaskState.Invalid)\n            ret = \"Invalid\";  \n        else if (tasks[_taskID].taskState == TaskState.ResultsReceived)\n            ret = \"ResultsReceived\";\n        else \n            ret = \"Error\";\n        return ret; \n    }\n\n    function getPaymentState(bytes32 _taskID) public clientOrProviderOnly(_taskID) view returns (string memory)\n    {\n        string memory ret = \"\";\n        if (tasks[_taskID].paymentState == PaymentState.Initialized) \n            ret = \"Initialized\";\n        else if (tasks[_taskID].paymentState == PaymentState.Pending) \n            ret = \"Pending\";\n        else if (tasks[_taskID].paymentState == PaymentState.Completed) \n            ret = \"Completed\";\n        else \n            ret = \"Error\";  \n        return ret; \n    }\n\n    function getCost(bytes32 _taskID) public clientOrProviderOnly(_taskID) view returns (uint)\n    {\n        return tasks[_taskID].cost;\n    }\n\n    function getPayment(bytes32 _taskID) public clientOrProviderOnly(_taskID) view returns (uint) \n    {\n        return (tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    function getTask(bytes32 _taskID) public ownerOnly view returns (Task memory) {\n        return tasks[_taskID];\n    }\n\n    // Fallback Function\n    fallback() external payable{\n        revert();\n    }\n\n    receive() external payable {\n        revert(\"bad call\");\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}