{
  "language": "Solidity",
  "sources": {
    "contracts/AuctionsManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./TasksManager.sol\";\n\ncontract AuctionsManager {\n     address private immutable owner; \n     TasksManager tasksManager;\n\n     enum AuctionState {\n        Created,\n        Cancelled, \n        Finalized\n    }\n\n    struct Auction {\n        bytes32 auctionID;\n        address client;\n        uint creationTime;\n        uint auctionDeadline;\n        uint taskDeadline;\n        bytes32 clientVerification;\n        bytes32 taskID;\n        string code;\n        ProviderBid[] providerBids;\n        WinnerBid winnerBid;\n        AuctionState auctionState;   \n    }\n\n    struct ProviderBid {\n        address provider;\n        uint bid;\n        uint providerUpVotes;\n        uint providerDownVotes;\n    }\n\n    struct WinnerBid {\n        address provider;\n        uint bid;\n    }\n\n    struct ActiveAuction {\n        Auction auction;\n        uint clientUpVotes;\n        uint clientDownVotes;\n    }\n\n    mapping (bytes32 => Auction) private auctions;\n\n    bytes32[] private bytes32_auctions;\n\n    //Events\n    event AuctionCreated(bytes32 auctionID, address client);\n    event AuctionCancelled(bytes32 auctionID, address client);\n    event AuctionFinalized(bytes32 auctionID, address client, address provider);\n    event AuctionDeleted(bytes32 auctionID);\n    event BidPlaced(bytes32 auctionID, address provider, uint bid);\n    event TaskIDCreated(bytes32 auctionID, bytes32 taskID, address client, address provider);\n\n    //Errors\n    error NotCalledByOwner();\n    error NotCalledByClient();\n    error AuctionDoesNotExist();\n    error AuctionNotInState(AuctionState auctionState);\n    error TasksManagerNotSet();\n\n    constructor()  {\n        owner = msg.sender;\n    }\n\n    function setTasksManager(address payable _tasksManagerAddress) public  {\n        //owner only\n        if (msg.sender != owner) \n            revert NotCalledByOwner();\n        tasksManager = TasksManager(_tasksManagerAddress);\n    }\n\n    function createAuction(\n        uint _auctionDeadline, \n        uint _taskDeadline,\n        bytes32 _clientVerification,\n        string memory _code\n    ) public \n    {\n        bytes32 _auctionID = keccak256(abi.encode(block.timestamp, msg.sender, _auctionDeadline, _taskDeadline, _clientVerification, _code));\n        auctions[_auctionID].auctionID = _auctionID;\n        auctions[_auctionID].client = msg.sender;\n        auctions[_auctionID].creationTime = block.timestamp;\n        auctions[_auctionID].auctionDeadline = _auctionDeadline;\n        auctions[_auctionID].taskDeadline = _taskDeadline;\n        auctions[_auctionID].clientVerification = _clientVerification;\n        auctions[_auctionID].code = _code;\n\n        auctions[_auctionID].auctionState = AuctionState.Created;\n        bytes32_auctions.push(_auctionID);\n        emit AuctionCreated( _auctionID, msg.sender);\n    }\n\n    function cancelAuction(bytes32 _auctionID) public   {\n        //existing auction\n        if (auctions[_auctionID].auctionID == bytes32(0))\n            revert AuctionDoesNotExist();   \n        //client only\n        if (msg.sender != auctions[_auctionID].client) \n            revert NotCalledByClient();\n        //in auction state Created\n        if (auctions[_auctionID].auctionState != AuctionState.Created) \n            revert AuctionNotInState(AuctionState.Created);\n        auctions[_auctionID].auctionState = AuctionState.Cancelled;\n        emit AuctionCancelled(_auctionID, auctions[_auctionID].client);\n     }\n\n    function bid(bytes32 _auctionID, uint _bid) public {\n        //tasks manager set\n        if (address(tasksManager) == address(0))\n            revert TasksManagerNotSet();\n        //existing auction\n        if (auctions[_auctionID].auctionID == bytes32(0))\n            revert AuctionDoesNotExist();\n        //in auction state Created\n        if (auctions[_auctionID].auctionState != AuctionState.Created) \n            revert AuctionNotInState(AuctionState.Created);\n        require(msg.sender != auctions[_auctionID].client, \"Client can't bid to this auction\"); \n        require(\n            (block.timestamp <= auctions[_auctionID].creationTime + auctions[_auctionID].auctionDeadline),\n            \"Time has expired.\"\n        );\n        uint providerIndex = 0;\n        bool providerExists = false;\n        if(auctions[_auctionID].providerBids.length != 0)\n        {    while(auctions[_auctionID].providerBids[providerIndex].provider != msg.sender)\n            {\n                providerIndex++;\n                if(providerIndex > auctions[_auctionID].providerBids.length)\n                    break;\n            }\n            if (providerIndex <= auctions[_auctionID].providerBids.length)\n            {\n                require(\n                _bid < auctions[_auctionID].providerBids[providerIndex].bid,\n                \"Bid is not lower than than the previous one.\"\n                );\n                providerExists = true;\n            }\n        }\n        if(providerExists == true)\n        {\n            auctions[_auctionID].providerBids[providerIndex].bid = _bid;\n            auctions[_auctionID].providerBids[providerIndex].providerUpVotes = tasksManager.getProviderPerformance(msg.sender).upVotes;\n            auctions[_auctionID].providerBids[providerIndex].providerDownVotes = tasksManager.getProviderPerformance(msg.sender).downVotes;\n        }\n        else \n        {\n            ProviderBid memory currentBid;\n            currentBid.provider = msg.sender;\n            currentBid.bid = _bid;\n            currentBid.providerUpVotes = tasksManager.getProviderPerformance(msg.sender).upVotes;\n            currentBid.providerDownVotes = tasksManager.getProviderPerformance(msg.sender).downVotes;\n            auctions[_auctionID].providerBids.push(currentBid);\n        }\n        emit BidPlaced(_auctionID, msg.sender, _bid);\n     }\n\n    function finalize(bytes32 _auctionID, address _provider) public payable  {\n        //existing auction\n        if (auctions[_auctionID].auctionID == bytes32(0))\n            revert AuctionDoesNotExist();\n        //client only\n        if (msg.sender != auctions[_auctionID].client) \n            revert NotCalledByClient();\n        //in auction state Created\n        if (auctions[_auctionID].auctionState != AuctionState.Created) \n            revert AuctionNotInState(AuctionState.Created);\n        uint providerIndex = 0;\n        if (auctions[_auctionID].providerBids.length == 0)\n            revert(\"Auction has no bids.\");\n        while(auctions[_auctionID].providerBids[providerIndex].provider != _provider)\n        {\n            providerIndex++;\n            if(providerIndex >= auctions[_auctionID].providerBids.length)\n                break;\n        }\n        if(providerIndex >= auctions[_auctionID].providerBids.length)\n         revert(\"Wrong provider address\");\n        WinnerBid memory _winnerBid;\n        _winnerBid.provider = _provider;\n        _winnerBid.bid = auctions[_auctionID].providerBids[providerIndex].bid;\n        require (msg.value ==(_winnerBid.bid * 2), \"Client collateral is not correct\");\n        auctions[_auctionID].winnerBid = _winnerBid;\n        Auction storage currentAuction = auctions[_auctionID];\n        auctions[_auctionID].auctionState = AuctionState.Finalized;\n        emit AuctionFinalized(_auctionID, auctions[_auctionID].client,  _provider);\n        bytes32 taskID = keccak256(abi.encode(currentAuction.client, _winnerBid, block.timestamp));\n        auctions[_auctionID].taskID = taskID;\n        emit TaskIDCreated(_auctionID, taskID, auctions[_auctionID].client , _provider);\n        uint clientCollateral = auctions[_auctionID].winnerBid.bid * 2;\n        tasksManager.createTask{value: clientCollateral}(taskID, currentAuction.client, _provider,  _winnerBid.bid, currentAuction.taskDeadline, currentAuction.clientVerification,currentAuction.code);\n    }\n\n    function getActiveAuctions() public view returns (ActiveAuction[] memory) {\n        Auction[] memory activeAuctions = new Auction[](bytes32_auctions.length);\n        uint auctionsLength = 0;\n        for (uint i = 0; i < bytes32_auctions.length; i++)\n        {\n            if (auctions[bytes32_auctions[i]].auctionState == AuctionState.Created && block.timestamp <= auctions[bytes32_auctions[i]].creationTime + auctions[bytes32_auctions[i]].auctionDeadline && auctions[bytes32_auctions[i]].client != msg.sender)\n            {\n                activeAuctions[auctionsLength] = auctions[bytes32_auctions[i]];\n                auctionsLength++;\n            }\n        }\n         ActiveAuction[] memory result = new ActiveAuction[](auctionsLength);\n        for (uint i = 0; i < auctionsLength; i++) \n        {\n            result[i].auction = activeAuctions[i];\n            result[i].clientUpVotes = tasksManager.getClientPerformance(activeAuctions[i].client).upVotes;\n            result[i].clientDownVotes = tasksManager.getClientPerformance(activeAuctions[i].client).downVotes;\n        }\n        return result;\n    }\n\n\n\n    function getAuctionBids(bytes32 _auctionID) public view returns(ProviderBid[] memory) {\n        return auctions[_auctionID].providerBids;\n    }\n\n    function getAuctionsByClient() public view returns(Auction[] memory)\n    {\n        Auction[] memory auctionsByClient = new Auction[](bytes32_auctions.length);\n        uint auctionsLength = 0;\n        for (uint i = 0; i < bytes32_auctions.length; i++)\n        {\n            if (auctions[bytes32_auctions[i]].client == msg.sender)\n            {\n                auctionsByClient[auctionsLength] = auctions[bytes32_auctions[i]];\n                auctionsLength++;\n            }\n        }\n        Auction[] memory result = new Auction[](auctionsLength);\n        for (uint i = 0; i < auctionsLength; i++) \n        {\n            result[i] = auctionsByClient[i];\n        }\n        return result;\n    }\n\n    function getAuctionWinnersByProvider() public view returns(Auction[] memory)\n    {\n        Auction[] memory auctionsByProvider = new Auction[](bytes32_auctions.length);\n        uint auctionsLength = 0;\n        for (uint i = 0; i < bytes32_auctions.length; i++)\n        {\n            if (auctions[bytes32_auctions[i]].winnerBid.provider == msg.sender)\n            {\n                auctionsByProvider[auctionsLength] = auctions[bytes32_auctions[i]];\n                auctionsLength++;\n            }\n        }\n        Auction[] memory result = new Auction[](auctionsLength);\n        for (uint i = 0; i < auctionsLength; i++) \n        {\n            result[i] = auctionsByProvider[i];\n        }\n        return result;\n    }\n\n    function getAuctionActiveBidsByProvider() public view returns (Auction[] memory) \n    {\n        Auction[] memory activeBidsByProvider = new Auction[](bytes32_auctions.length);\n        uint auctionsLength = 0;\n        for (uint i = 0; i < bytes32_auctions.length; i++)\n        {\n            if (auctions[bytes32_auctions[i]].auctionState == AuctionState.Created && block.timestamp <= auctions[bytes32_auctions[i]].creationTime + auctions[bytes32_auctions[i]].auctionDeadline)\n            {\n                for (uint j = 0; j < auctions[bytes32_auctions[i]].providerBids.length; j++)\n                {\n                    if (auctions[bytes32_auctions[i]].providerBids[j].provider == msg.sender)\n                    {\n                        activeBidsByProvider[auctionsLength] = auctions[bytes32_auctions[i]];\n                        auctionsLength++;\n                        break;\n                    }\n                }\n            }\n        }\n        Auction[] memory result = new Auction[](auctionsLength);\n        for (uint i = 0; i < auctionsLength; i++) \n        {\n            result[i] = activeBidsByProvider[i];\n        }\n        return result;\n    }\n\n    function getOwner() public view returns(address) {\n        return owner;\n    }\n    \n    function getTasksManager() public view returns(address) {\n         //owner only\n        if (msg.sender != owner) \n            revert NotCalledByOwner();\n        return address(tasksManager);\n    }\n\n    // Fallback Function\n    fallback() external payable{\n        revert();\n    }\n\n    receive() external payable {\n        revert(\"bad call\");\n    }\n}"
    },
    "contracts/TasksManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract TasksManager {\n\n    address private immutable owner; \n    address private auctionAddress;\n    uint private bank = 0;\n\n    enum TaskState {\n        Created,\n        Cancelled, \n        Active,\n        CompletedSuccessfully,\n        CompletedUnsuccessfully,\n        Invalid, \n        ResultsReceivedSuccessfully,\n        ResultsReceivedUnsuccessfully\n    }\n\n    enum PaymentState {\n        Initialized,\n        Pending,\n        Completed \n    }\n\n    struct Task {\n        bytes32 taskID;\n        address payable client; \n        address payable provider;\n        uint deadline;\n        uint price;\n        uint duration;\n        uint activationTime;\n        uint completionTime;\n        string code;\n        string results;\n        bytes32 clientVerification;\n        TaskState taskState;\n        PaymentState paymentState;\n    }\n\n    struct providerRating {\n        uint upVotes;\n        uint downVotes;\n    }\n\n    struct clientRating {\n        uint upVotes;\n        uint downVotes;\n    }\n\n    mapping (bytes32 => Task) private tasks;\n    bytes32[] private bytes32_tasks;\n    mapping(address => providerRating) private providerPerformance;\n    mapping(address => clientRating) private clientPerformance;\n\n    //Events\n    event TaskCreated(bytes32 taskID, address client, address provider);\n    event TaskActivated(bytes32 taskID, address client, address provider);\n    event TaskCompletedSuccessfully(bytes32 taskID, address client, address provider);\n    event TaskCompletedUnsuccessfully(bytes32 taskID, address client, address provider);\n    event TaskReceivedResultsSuccessfully(bytes32 taskID, address client, address provider);\n    event TaskReceivedResultsUnsuccessfully(bytes32 taskID, address client, address provider);\n    event TaskCancelled(bytes32 taskID, address client, address provider);\n    event TaskInvalidated(bytes32 taskID, address client, address provider);\n    event PaymentPending(bytes32 taskID, address client, address provider, uint payment);\n    event PaymentCompleted(bytes32 taskID, address client, address provider);\n    event TransferMadeToClient(address client, uint amount);\n    event TransferMadeToProvider(address provider, uint amount);\n    event ProviderUpvoted(address provider, bytes32 taskID);\n    event ProviderDownvoted(address provider, bytes32 taskID);\n    event ClientUpvoted(address client, bytes32 taskID);\n    event ClientDownvoted(address client, bytes32 taskID);\n\n    //Errors\n    error NotCalledByOwner();\n    error NotCalledByAuction();\n    error NotCalledByClient();\n    error NotCalledByProvider();\n    error NotCorrectValue(uint correctValue, uint receivedValue);\n    error TaskNotInState(TaskState taskState);\n    error PaymentNotInState(PaymentState paymentState);\n    error TaskDoesNotExist();\n    error TaskAlreadyExists();\n    error AuctionsManagerNotSet();\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function setAuctionsManager(address _auctionAddress) public  {\n        //owner only\n        if (msg.sender != owner) \n            revert NotCalledByOwner();\n        auctionAddress = _auctionAddress;\n    }\n\n    function createTask(\n        bytes32 _taskID,\n        address _client,\n        address _provider,\n        uint _price,\n        uint _deadline,\n        bytes32 _clientVerification,\n        string memory _code\n    ) public payable \n    {\n        //auctions manager set\n        if (auctionAddress == address(0)) \n            revert AuctionsManagerNotSet();\n        //auction only\n        if (msg.sender != auctionAddress) \n            revert NotCalledByAuction();\n        //not registered task\n        if (tasks[_taskID].taskID != bytes32(0)) \n            revert TaskAlreadyExists();\n        //correct client collateral\n        if (msg.value != _price * 2)\n            revert NotCorrectValue(_price * 2, msg.value);\n        tasks[_taskID].taskID = _taskID;\n        tasks[_taskID].client = payable (_client);\n        tasks[_taskID].provider = payable(_provider);\n        tasks[_taskID].price = _price;\n        tasks[_taskID].deadline = _deadline;\n        tasks[_taskID].clientVerification = _clientVerification;\n        tasks[_taskID].code = _code;\n        tasks[_taskID].taskState = TaskState.Created;\n        tasks[_taskID].paymentState = PaymentState.Initialized;\n        bytes32_tasks.push(_taskID);\n        emit TaskCreated(_taskID, _client, _provider);\n        //clientCollateral = 2 * price\n        //providerCollateral = 10 * price\n    }\n\n    //Cancel\n    //TaskState -> Cancel\n    //refunds payment to client\n    //can be called only by client and only if contract hasnt been activated by provider\n\n    function cancelTask(bytes32 _taskID) public \n    {\n        //registered task\n        if (tasks[_taskID].taskID == bytes32(0)) \n            revert TaskDoesNotExist();\n        //client only\n        if (msg.sender != tasks[_taskID].client) \n            revert NotCalledByClient();\n        //in task state Created\n        if (tasks[_taskID].taskState != TaskState.Created) \n            revert TaskNotInState(TaskState.Created);\n        tasks[_taskID].taskState = TaskState.Cancelled;\n        tasks[_taskID].client.transfer(tasks[_taskID].price * 2);\n        emit TransferMadeToClient(tasks[_taskID].client,tasks[_taskID].price * 2);\n        emit TaskCancelled(_taskID, tasks[_taskID].client, tasks[_taskID].provider);\n    }\n\n    function invalidateTask(bytes32 _taskID) public \n    {\n        //registered task\n        if (tasks[_taskID].taskID == bytes32(0)) \n            revert TaskDoesNotExist();\n         //client only\n        if (msg.sender != tasks[_taskID].client) \n            revert NotCalledByClient();\n        //in task state Active\n        if (tasks[_taskID].taskState != TaskState.Active) \n            revert TaskNotInState(TaskState.Active);\n        require(\n            (block.timestamp > tasks[_taskID].activationTime + tasks[_taskID].deadline + 86400), //give one day to be invalidated\n            \"Time has not expired.\"\n        );\n        tasks[_taskID].taskState = TaskState.Invalid;\n  \n        tasks[_taskID].client.transfer(tasks[_taskID].price * 12 ); //clientCollateral + providerCollateral\n        emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].price * 12);\n        emit TaskInvalidated(_taskID, tasks[_taskID].client, tasks[_taskID].provider);\n    }\n\n    // Activate\n    // TaskState -> Activated\n    // can be called only by provider to start the process\n\n    function activateTask(bytes32 _taskID) public payable\n    {\n        //registered task\n        if (tasks[_taskID].taskID == bytes32(0)) \n            revert TaskDoesNotExist();\n        //provider only\n        if (msg.sender != tasks[_taskID].provider) \n            revert NotCalledByProvider();\n        //in taskState Created\n        if (tasks[_taskID].taskState != TaskState.Created) \n            revert TaskNotInState(TaskState.Created);\n        //correct provider collateral\n        if (msg.value != tasks[_taskID].price * 10)\n            revert NotCorrectValue(tasks[_taskID].price * 10, msg.value);\n        tasks[_taskID].activationTime = block.timestamp;\n        tasks[_taskID].taskState = TaskState.Active;\n        emit TaskActivated(_taskID, tasks[_taskID].client ,tasks[_taskID].provider);\n    }\n\n    // Complete\n    // TaskState -> Completed\n    // can be called only by provider when the computation is over\n\n    //called by docker container\n    function completeTask(bytes32 _taskID,string memory ver,  uint _duration, uint _timeReceivedProvider) public\n    {\n        //registered task\n        if (tasks[_taskID].taskID == bytes32(0)) \n            revert TaskDoesNotExist();\n        //provider only\n        if (msg.sender != tasks[_taskID].provider) \n            revert NotCalledByProvider();\n        //in task state Active\n        if (tasks[_taskID].taskState != TaskState.Active) \n            revert TaskNotInState(TaskState.Active);\n        tasks[_taskID].completionTime = _timeReceivedProvider;\n        tasks[_taskID].duration = _duration;\n        //in time and correct verification\n        if ((tasks[_taskID].completionTime <= tasks[_taskID].activationTime + tasks[_taskID].deadline) \n            && (tasks[_taskID].duration <= tasks[_taskID].deadline) \n            && (tasks[_taskID].clientVerification == keccak256(abi.encodePacked(ver))))\n        {\n            tasks[_taskID].taskState = TaskState.CompletedSuccessfully;\n            emit TaskCompletedSuccessfully(_taskID, tasks[_taskID].client, tasks[_taskID].provider);\n        }\n        else {\n            tasks[_taskID].client.transfer(tasks[_taskID].price * 2);\n            emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].price * 2);\n            bank += tasks[_taskID].price * 10; //providerCollateral to bank\n            providerPerformance[tasks[_taskID].provider].downVotes += 1;\n            emit ProviderDownvoted(tasks[_taskID].provider,_taskID);\n            tasks[_taskID].taskState = TaskState.CompletedUnsuccessfully;\n            emit TaskCompletedUnsuccessfully(_taskID, tasks[_taskID].client, tasks[_taskID].provider);\n        }\n    }\n\n\n    //called by provider\n    function sendResults(bytes32 _taskID, string memory _results) public {\n        //registered task\n        if (tasks[_taskID].taskID == bytes32(0)) \n            revert TaskDoesNotExist();\n        //provider only\n        if (msg.sender != tasks[_taskID].provider) \n            revert NotCalledByProvider();\n        //in task state CompletedSuccessfully\n        if (tasks[_taskID].taskState != TaskState.CompletedSuccessfully) \n            revert TaskNotInState(TaskState.CompletedSuccessfully);\n        //in payment state Initialized\n        if (tasks[_taskID].paymentState != PaymentState.Initialized) \n            revert PaymentNotInState(PaymentState.Initialized);\n        uint receiptTime = block.timestamp;\n        tasks[_taskID].results = _results;\n        //gives 600 sec to provider to send the results, time received must be greater than completion time\n        if ((receiptTime >= tasks[_taskID].completionTime)\n        && (receiptTime <= tasks[_taskID].completionTime + 86400) \n        && (receiptTime >= tasks[_taskID].activationTime + tasks[_taskID].duration) \n        && (tasks[_taskID].completionTime >= tasks[_taskID].activationTime + tasks[_taskID].duration)) \n        {\n            if (tasks[_taskID].price * tasks[_taskID].duration <= tasks[_taskID].price * 2) {\n                tasks[_taskID].provider.transfer(tasks[_taskID].price * tasks[_taskID].duration + tasks[_taskID].price * 10);\n                emit TransferMadeToProvider(tasks[_taskID].provider, tasks[_taskID].price * tasks[_taskID].duration + tasks[_taskID].price * 10);\n                tasks[_taskID].client.transfer(tasks[_taskID].price * tasks[_taskID].duration - tasks[_taskID].price * 2);\n                emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].price * tasks[_taskID].duration - tasks[_taskID].price * 2);\n                tasks[_taskID].paymentState = PaymentState.Completed;\n                emit PaymentCompleted(_taskID, tasks[_taskID].client, tasks[_taskID].provider);                \n            }\n            else {\n                tasks[_taskID].provider.transfer(tasks[_taskID].price * 12); //clientCollateral + providerCollateral\n                emit TransferMadeToProvider(tasks[_taskID].provider, tasks[_taskID].price * 12);\n                tasks[_taskID].paymentState = PaymentState.Pending;\n                emit PaymentPending(_taskID, tasks[_taskID].client, tasks[_taskID].provider, tasks[_taskID].price * tasks[_taskID].duration - tasks[_taskID].price * 2);\n            }\n            tasks[_taskID].taskState = TaskState.ResultsReceivedSuccessfully;\n            emit TaskReceivedResultsSuccessfully(_taskID, tasks[_taskID].client, tasks[_taskID].provider);\n            providerPerformance[tasks[_taskID].provider].upVotes += 1;\n            emit ProviderUpvoted(tasks[_taskID].provider,_taskID);\n        }\n        else {\n            tasks[_taskID].client.transfer(tasks[_taskID].price * 2);\n            emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].price * 2);\n            bank += tasks[_taskID].price * 10; //providerCollateral to bank\n            tasks[_taskID].taskState = TaskState.ResultsReceivedUnsuccessfully;\n            emit TaskReceivedResultsUnsuccessfully(_taskID, tasks[_taskID].client, tasks[_taskID].provider);\n            providerPerformance[tasks[_taskID].provider].downVotes += 1;\n            emit ProviderDownvoted(tasks[_taskID].provider,_taskID);\n        }\n    }\n\n\n    function completePayment(bytes32 _taskID) public payable {\n        //registered task\n        if (tasks[_taskID].taskID == bytes32(0)) \n            revert TaskDoesNotExist();\n        //client only\n        if (msg.sender != tasks[_taskID].client) \n            revert NotCalledByClient();\n        //correct payment value\n        if (msg.value != tasks[_taskID].price * tasks[_taskID].duration - tasks[_taskID].price * 2)\n            revert NotCorrectValue(tasks[_taskID].price * tasks[_taskID].duration - tasks[_taskID].price * 2, msg.value);\n        //in task state ResultsReceivedSuccessfully\n        if (tasks[_taskID].taskState != TaskState.ResultsReceivedSuccessfully) \n            revert TaskNotInState(TaskState.ResultsReceivedSuccessfully);\n        //in payment state Pending\n        if (tasks[_taskID].paymentState != PaymentState.Pending) \n            revert PaymentNotInState(PaymentState.Pending);\n        tasks[_taskID].provider.transfer(msg.value);\n        emit TransferMadeToProvider(tasks[_taskID].provider, tasks[_taskID].price * tasks[_taskID].duration - tasks[_taskID].price * 2);\n        clientPerformance[tasks[_taskID].client].upVotes += 1;\n        emit ClientUpvoted(tasks[_taskID].client,_taskID);\n        tasks[_taskID].paymentState = PaymentState.Completed;\n        emit PaymentCompleted(_taskID, tasks[_taskID].client, tasks[_taskID].provider);\n    }\n\n    function reportClient(bytes32 _taskID) public {\n       //registered task\n        if (tasks[_taskID].taskID == bytes32(0)) \n            revert TaskDoesNotExist();\n        //provider only\n        if (msg.sender != tasks[_taskID].provider) \n            revert NotCalledByProvider(); \n        clientPerformance[tasks[_taskID].client].downVotes += 1;\n        emit ClientDownvoted(tasks[_taskID].client,_taskID);\n    }\n\n\n    function getProviderPerformance(address provider) public view returns (providerRating memory) {\n        return providerPerformance[provider];\n        // tuple: upVotes, downVotes\n    }\n\n    function getClientPerformance(address client) public view returns (clientRating memory) {\n        return clientPerformance[client];\n        // tuple: upVotes, downVotes\n    }\n\n    function getCode(bytes32 _taskID) public view returns (string memory) {\n        //registered task\n        if (tasks[_taskID].taskID == bytes32(0)) \n            revert TaskDoesNotExist();\n        //provider only\n        if (msg.sender != tasks[_taskID].provider) \n            revert NotCalledByProvider();\n        //in task state Active\n        if (tasks[_taskID].taskState != TaskState.Active) \n            revert TaskNotInState(TaskState.Active);\n        return tasks[_taskID].code;\n    }\n\n    function getResults(bytes32 _taskID) public view returns (string memory)  {\n        //registered task\n        if (tasks[_taskID].taskID == bytes32(0)) \n            revert TaskDoesNotExist();\n        //client only\n        if (msg.sender != tasks[_taskID].client) \n            revert NotCalledByClient();\n        //in task state ResultsReceivedSuccessfully\n        if (tasks[_taskID].taskState != TaskState.ResultsReceivedSuccessfully) \n            revert TaskNotInState(TaskState.ResultsReceivedSuccessfully);\n        //in payment state Completed\n        if (tasks[_taskID].paymentState != PaymentState.Completed) \n            revert PaymentNotInState(PaymentState.Completed);\n        return tasks[_taskID].results;\n    }\n\n    function getTasksByClient() public view returns (Task[] memory) {\n        Task[] memory tasksByClient = new Task[](bytes32_tasks.length);\n        uint counter = 0;\n        for (uint i = 0; i < bytes32_tasks.length; i++) {\n            if (tasks[bytes32_tasks[i]].client == msg.sender) {\n                tasksByClient[counter] = tasks[bytes32_tasks[i]];\n                counter++;\n            }\n        }\n        Task[] memory ret = new Task[](counter);\n        for (uint i = 0; i < counter; i++) \n        {\n            ret[i] = tasksByClient[i];\n        }\n        return ret;\n    }\n\n    function getTasksByProvider() public view returns (Task[] memory) {\n        Task[] memory tasksByProvider = new Task[](bytes32_tasks.length);\n        uint counter = 0;\n        for (uint i = 0; i < bytes32_tasks.length; i++) {\n            if (tasks[bytes32_tasks[i]].provider == msg.sender) {\n                tasksByProvider[counter] = tasks[bytes32_tasks[i]];\n                counter++;\n            }\n        }\n        Task[] memory ret = new Task[](counter);\n         for (uint i = 0; i < counter; i++) \n        {\n            ret[i] = tasksByProvider[i];\n        }\n        return ret;\n    }\n\n    function getProviderCollateral(bytes32 _taskID) public view returns (uint) {\n        //registered task\n        if (tasks[_taskID].taskID == bytes32(0)) \n            revert TaskDoesNotExist();\n        //provider only\n        if (msg.sender != tasks[_taskID].provider) \n            revert NotCalledByProvider();\n        //in task state Created\n        if (tasks[_taskID].taskState != TaskState.Created) \n            revert TaskNotInState(TaskState.Created);\n        return tasks[_taskID].price * 10;\n    }\n\n    function getClientCollateral(bytes32 _taskID) public view returns (uint) {\n        //registered task\n        if (tasks[_taskID].taskID == bytes32(0)) \n            revert TaskDoesNotExist();\n        //client only\n        if (msg.sender != tasks[_taskID].client) \n            revert NotCalledByClient();\n        //in task state Created\n        if (tasks[_taskID].taskState != TaskState.Created) \n            revert TaskNotInState(TaskState.Created);\n        return tasks[_taskID].price * 2;\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    function getAuctionAddress() public  view returns (address) {\n        //owner only\n        if (msg.sender != owner) \n            revert NotCalledByOwner();\n        return auctionAddress;\n    }\n\n    function getTasks() public view returns (Task[] memory) {\n        //owner only\n        if (msg.sender != owner) \n            revert NotCalledByOwner();\n        Task[] memory ret = new Task[](bytes32_tasks.length);\n        for (uint i = 0; i < bytes32_tasks.length; i++) {\n            ret[i] = tasks[bytes32_tasks[i]];\n        }\n        return ret;\n    }\n\n    function getBank() public view returns (uint) {\n        //owner only\n        if (msg.sender != owner) \n            revert NotCalledByOwner();\n        return bank;\n    }\n\n    function withdraw(uint amount) public {\n        //owner only\n        if (msg.sender != owner) \n            revert NotCalledByOwner();\n        //correct amount\n        if (amount > bank)\n            revert NotCorrectValue(bank, amount);\n        payable(owner).transfer(amount);\n        bank -= amount;\n    }\n\n\n    // Fallback Function\n    fallback() external payable{\n        revert();\n    }\n\n    receive() external payable {\n        revert(\"bad call\");\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}