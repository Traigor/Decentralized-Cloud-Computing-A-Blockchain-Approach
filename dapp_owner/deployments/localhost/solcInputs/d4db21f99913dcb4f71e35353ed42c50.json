{
  "language": "Solidity",
  "sources": {
    "contracts/AuctionsManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./TasksManager.sol\";\n\ncontract AuctionsManager {\n     address private immutable owner; \n     TasksManager tasksManager;\n\n     enum AuctionState {\n        Created,\n        Cancelled, \n        Finalized\n    }\n\n    struct Auction {\n        address client;\n        uint creationTime;\n        uint auctionDeadline;\n        uint taskDeadline;\n        bytes32 clientVerification;\n        string computationCode;\n        string verificationCode;\n        ProviderBid[] providerBids;\n        WinnerBid winnerBid;\n        AuctionState auctionState;   \n        uint lastUpdateTimestamp;\n    }\n\n    struct ProviderBid {\n        address provider;\n        uint bid;\n        uint providerUpVotes;\n        uint providerDownVotes;\n    }\n\n    struct WinnerBid {\n        address provider;\n        uint bid;\n    }\n\n    mapping (bytes32 => Auction) private auctions;\n    bytes32[] private bytes32_auctions;\n\n    event AuctionCreated(bytes32 auctionID);\n    event AuctionCancelled(bytes32 auctionID);\n    event AuctionFinalized(bytes32 auctionID, address provider);\n    event AuctionDeleted(bytes32 auctionID);\n    event BidPlaced(bytes32 auctionID, address provider, uint bid);\n\n    modifier ownerOnly() {\n        require(\n            msg.sender == owner,\n            \"Method can be called only by owner.\"\n        );\n        _;\n    }\n\n    modifier clientOnly(bytes32 _auctionID) {\n        require(\n            msg.sender == auctions[_auctionID].client,\n            \"Method can be called only by client.\"\n        );\n        _;\n    }\n\n    modifier inAuctionState(bytes32 _auctionID,AuctionState _auctionState) {\n        require(\n            auctions[_auctionID].auctionState == _auctionState,\n            \"Invalid AuctionState.\"\n        );\n        _;\n    }\n\n\n    modifier existingAuctionOnly(bytes32 _auctionID) {\n        require(\n            auctionExists(_auctionID),\n            \"Auction must exist\"\n        );\n        _;\n    }\n\n    modifier notExistingAuctionOnly(bytes32 _auctionID) {\n        require(\n            !auctionExists(_auctionID),\n            \"Auction already exists\"\n        );\n        _;\n    }\n\n\n    constructor(address payable _tasksManager)  {\n        owner = msg.sender;\n        tasksManager = TasksManager(_tasksManager);\n    }\n\n    function createAuction(\n        bytes32 _auctionID, \n        uint _auctionDeadline, \n        uint _taskDeadline,\n        bytes32 _clientVerification,\n        string memory _verificationCode,\n        string memory _computationCode\n    ) public notExistingAuctionOnly(_auctionID)\n        {\n        auctions[_auctionID].client = msg.sender;\n        auctions[_auctionID].creationTime = block.timestamp;\n        auctions[_auctionID].auctionDeadline = _auctionDeadline;\n        auctions[_auctionID].taskDeadline = _taskDeadline;\n        auctions[_auctionID].clientVerification = _clientVerification;\n        auctions[_auctionID].verificationCode = _verificationCode;\n        auctions[_auctionID].computationCode = _computationCode;\n\n        auctions[_auctionID].auctionState = AuctionState.Created;\n        auctions[_auctionID].lastUpdateTimestamp = block.timestamp;\n        bytes32_auctions.push(_auctionID);\n        emit AuctionCreated(_auctionID);\n    }\n\n    function cancelAuction(bytes32 _auctionID) public clientOnly(_auctionID) inAuctionState(_auctionID, AuctionState.Created) existingAuctionOnly(_auctionID) {\n        auctions[_auctionID].auctionState = AuctionState.Cancelled;\n        auctions[_auctionID].lastUpdateTimestamp = block.timestamp;\n        emit AuctionCancelled(_auctionID);\n     }\n\n    function bid(bytes32 _auctionID, uint _bid) public  inAuctionState(_auctionID, AuctionState.Created)  existingAuctionOnly(_auctionID) {\n        require(msg.sender != auctions[_auctionID].client, \"Client can't bid to this auction\"); \n        require(\n            (block.timestamp <= auctions[_auctionID].creationTime + auctions[_auctionID].auctionDeadline),\n            \"Time has expired.\"\n        );\n        uint providerIndex = 0;\n        if(auctions[_auctionID].providerBids.length != 0)\n        {    while(auctions[_auctionID].providerBids[providerIndex].provider != msg.sender)\n            {\n                providerIndex++;\n                if(providerIndex > auctions[_auctionID].providerBids.length)\n                    break;\n            }\n            if (providerIndex <= auctions[_auctionID].providerBids.length)\n            {\n                require(\n                _bid < auctions[_auctionID].providerBids[providerIndex].bid,\n                \"Bid is not lower than than the previous one.\"\n                );\n            }\n        }\n        ProviderBid memory currentBid;\n        currentBid.provider = msg.sender;\n        currentBid.bid = _bid;\n        currentBid.providerUpVotes = tasksManager.getPerformance(msg.sender).upVotes;\n        currentBid.providerDownVotes = tasksManager.getPerformance(msg.sender).downVotes;\n        auctions[_auctionID].providerBids.push(currentBid);\n        auctions[_auctionID].lastUpdateTimestamp = block.timestamp;\n        emit BidPlaced(_auctionID, msg.sender, _bid);\n     }\n\n    function finalize(bytes32 _auctionID, address _provider) public payable clientOnly(_auctionID) inAuctionState(_auctionID, AuctionState.Created) existingAuctionOnly(_auctionID) returns (bytes32) {\n        uint providerIndex = 0;\n        if (auctions[_auctionID].providerBids.length == 0)\n            revert(\"Auction has no bids.\");\n        while(auctions[_auctionID].providerBids[providerIndex].provider != _provider)\n        {\n            providerIndex++;\n            if(providerIndex >= auctions[_auctionID].providerBids.length)\n                break;\n        }\n        if(providerIndex >= auctions[_auctionID].providerBids.length)\n         revert(\"Wrong provider address\");\n        WinnerBid memory _winnerBid;\n        _winnerBid.provider = _provider;\n        _winnerBid.bid = auctions[_auctionID].providerBids[providerIndex].bid;\n        require (msg.value >= _winnerBid.bid * 2, \"Client collateral is not enough\");\n        auctions[_auctionID].winnerBid = _winnerBid;\n        Auction storage currentAuction = auctions[_auctionID];\n        auctions[_auctionID].auctionState = AuctionState.Finalized;\n        auctions[_auctionID].lastUpdateTimestamp = block.timestamp;\n        emit AuctionFinalized(_auctionID, _provider);\n        bytes32 taskID = keccak256(abi.encode(currentAuction.client, _winnerBid, block.timestamp));\n        uint clientCollateral = getClientCollateral(_auctionID);\n        tasksManager.createTask{value: clientCollateral}(taskID, currentAuction.client, _provider,  _winnerBid.bid, currentAuction.taskDeadline, currentAuction.clientVerification,currentAuction.verificationCode, currentAuction.computationCode);\n        return taskID; //check for return, else add event TaskCreated\n    }\n\n    function getClientCollateral(bytes32 _auctionID) private view returns (uint) {\n        return auctions[_auctionID].winnerBid.bid * 2;\n    }\n\n    function auctionExists(bytes32 _auctionID) public view returns (bool) {\n            return (auctions[_auctionID].client != address(0));\n        }\n\n    function deleteAuctions() public ownerOnly { \n        for (uint i = bytes32_auctions.length; i > 0; i--)\n        {\n            bytes32 _auctionID = bytes32_auctions[i-1];\n            if ((auctions[_auctionID].auctionState == AuctionState.Finalized \n            || auctions[_auctionID].auctionState == AuctionState.Cancelled)\n            && block.timestamp > auctions[_auctionID].lastUpdateTimestamp + 60)\n            {\n                delete(auctions[_auctionID]);\n                bytes32_auctions[i-1] = bytes32_auctions[bytes32_auctions.length - 1];\n                bytes32_auctions.pop();\n                emit AuctionDeleted(_auctionID);\n            }\n        }\n    }\n\n    function deleteAuction(bytes32 _auctionID) public ownerOnly existingAuctionOnly(_auctionID) {\n        delete(auctions[_auctionID]);\n        for (uint i=0; i < bytes32_auctions.length; i++)\n        {\n            if (bytes32_auctions[i] == _auctionID)\n            {\n                bytes32_auctions[i] = bytes32_auctions[bytes32_auctions.length - 1];\n                bytes32_auctions.pop();\n                break;\n            }\n        }\n        emit AuctionDeleted(_auctionID);\n    }\n\n    function getActiveAuctions() ownerOnly public view returns (uint256) {\n        return bytes32_auctions.length;\n    }\n\n    function getAuctionBids(bytes32 _auctionID) public view returns(ProviderBid[] memory) {\n        return auctions[_auctionID].providerBids;\n    }\n\n    function getWinnerBid(bytes32 _auctionID) public view returns(WinnerBid memory) {\n        return auctions[_auctionID].winnerBid;\n    }\n\n    function getAuctionState(bytes32 _auctionID) public view returns(string memory) {\n        string memory ret = \"\";\n        if (auctions[_auctionID].auctionState == AuctionState.Created) \n            ret = \"Created\";\n        else if (auctions[_auctionID].auctionState == AuctionState.Cancelled) \n            ret = \"Cancelled\";\n        else if (auctions[_auctionID].auctionState == AuctionState.Finalized) \n            ret = \"Finalized\";\n        else \n            ret = \"Error\";\n        return ret;\n    }\n\n    function getOwner() public view returns(address) {\n        return owner;\n    }\n    \n    function getTasksManager() public view returns(address) {\n        return address(tasksManager);\n    }\n}"
    },
    "contracts/TasksManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract TasksManager {\n\n    address private immutable owner; \n    address private auctionAddress;\n\n    enum TaskState {\n        Created,\n        Cancelled, \n        Active,\n        CompletedSuccessfully,\n        CompletedUnsuccessfully,\n        Invalid, \n        ResultsReceivedSuccessfully,\n        ResultsReceivedUnsuccessfully\n    }\n\n    enum PaymentState {\n        Initialized,\n        Pending,\n        Completed \n    }\n\n    struct Task {\n        address payable client; \n        address payable provider;\n        uint providerCollateral;\n        uint clientCollateral; \n        uint deadline;\n        uint price;\n        uint duration;\n        uint cost;       \n        uint activationTime;\n        uint timeResultProvided;\n        uint timeResultReceived;\n        string computationCode;\n        string verificationCode;\n        string results;\n        bytes32 clientVerification;\n        uint lastUpdateTimestamp;\n        TaskState taskState;\n        PaymentState paymentState;\n    }\n\n    struct providerRating {\n        uint upVotes;\n        uint downVotes;\n    }\n\n    mapping (bytes32 => Task) private tasks;\n    bytes32[] private bytes32_tasks;\n    mapping(address => providerRating) private performance;\n\n    //Events\n    event TaskCreated(bytes32 taskID);\n    event TaskActivated(bytes32 taskID);\n    event TaskCompletedSuccessfully(bytes32 taskID);\n    event TaskCompletedUnsuccessfully(bytes32 taskID);\n    event TaskReceivedResultsSuccessfully(bytes32 taskID);\n    event TaskReceivedResultsUnsuccessfully(bytes32 taskID);\n    event TaskCancelled(bytes32 taskID);\n    event TaskInvalidated(bytes32 taskID);\n    event PaymentPending(bytes32 taskID, uint payment);\n    event PaymentCompleted(bytes32 taskID);\n    event TransferMadeToClient(address client, uint amount);\n    event TransferMadeToProvider(address provider, uint amount);\n    event ProviderUpvoted(address provider, bytes32 taskID);\n    event ProviderDownvoted(address provider, bytes32 taskID);\n    event TaskDeleted(bytes32 taskID);\n\n    //Modifiers\n\n    modifier ownerOnly() {\n        require(\n            msg.sender == owner,\n            \"Method can be called only by owner.\"\n        );\n        _;\n    }\n\n    modifier auctionOnly() {\n        require(\n            msg.sender == auctionAddress,\n            \"Method can be called only by auction.\"\n        );\n        _;\n    }\n\n    modifier clientOnly(bytes32 _taskID) {\n        require(\n            msg.sender == tasks[_taskID].client,\n            \"Method can be called only by client.\"\n        );\n        _;\n    }\n\n    modifier providerOnly(bytes32 _taskID) {\n        require(\n            msg.sender == tasks[_taskID].provider,\n            \"Method can be called only by provider.\"\n        );\n        _;\n    }\n\n    modifier clientOrProviderOnly(bytes32 _taskID) {\n        require(\n            (msg.sender == tasks[_taskID].client) || (msg.sender == tasks[_taskID].provider) || (msg.sender == owner),\n            \"Method can be called only by client, provider or the owner.\"\n        );\n        _;\n    }\n\n    modifier inTaskState(bytes32 _taskID,TaskState _taskState) {\n        require(\n            tasks[_taskID].taskState == _taskState,\n            \"Invalid TaskState.\"\n        );\n        _;\n    }\n\n    modifier inPaymentState(bytes32 _taskID,PaymentState _paymentState) {\n        require(\n            tasks[_taskID].paymentState == _paymentState,\n            \"Invalid PaymentState.\"\n        );\n        _;\n    }\n\n    modifier requiresValue(uint amount) {\n        require(\n            msg.value == amount,\n            \"Value sent is not the expected\"\n        );\n        _;\n    }\n\n    modifier registeredTaskOnly(bytes32 _taskID) {\n        require(\n            isRegistered(_taskID),\n            \"Task must be registered\"\n        );\n        _;\n    }\n\n    modifier notRegisteredTaskOnly(bytes32 _taskID) {\n        require(\n            !isRegistered(_taskID),\n            \"Task already exists\"\n        );\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function createTask(\n        bytes32 _taskID, \n        address _client,\n        address _provider,\n        uint _price,\n        uint _deadline,\n        bytes32 _clientVerification,\n        string memory _verificationCode,\n        string memory _computationCode\n    ) public payable notRegisteredTaskOnly(_taskID) auctionOnly\n    {\n        require (msg.value >= _price * 2, \"Client collateral is not enough\");\n        tasks[_taskID].client = payable (_client);\n        tasks[_taskID].clientCollateral = msg.value;\n        tasks[_taskID].provider = payable(_provider);\n        tasks[_taskID].providerCollateral = _price * 10;\n        tasks[_taskID].price = _price;\n        tasks[_taskID].deadline = _deadline;\n        tasks[_taskID].clientVerification = _clientVerification;\n        tasks[_taskID].verificationCode = _verificationCode;\n        tasks[_taskID].computationCode = _computationCode;\n        tasks[_taskID].taskState = TaskState.Created;\n        tasks[_taskID].paymentState = PaymentState.Initialized;\n        tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n        bytes32_tasks.push(_taskID);\n        emit TaskCreated(_taskID);\n    }\n\n    //Cancel\n    //TaskState -> Cancel\n    //refunds payment to client\n    //can be called only by client and only if contract hasnt been activated by provider\n\n    function cancelTask(bytes32 _taskID) public clientOnly(_taskID) inTaskState(_taskID,TaskState.Created) \n    {\n        tasks[_taskID].taskState = TaskState.Cancelled;\n        tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral);\n        tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n        emit TransferMadeToClient(tasks[_taskID].client,tasks[_taskID].clientCollateral);\n        emit TaskCancelled(_taskID);\n    }\n\n    function invalidateTask(bytes32 _taskID) public  clientOnly(_taskID) inTaskState(_taskID, TaskState.Active) \n    {\n        require(\n            (block.timestamp > tasks[_taskID].activationTime + tasks[_taskID].deadline),\n            \"Time has not expired.\"\n        );\n        tasks[_taskID].taskState = TaskState.Invalid;\n  \n        tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n        tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n        emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n        emit TaskInvalidated(_taskID);\n    }\n\n    // Activate\n    // TaskState -> Activated\n    // can be called only by provider to start the process\n\n    function activateTask(bytes32 _taskID) public payable providerOnly(_taskID) inTaskState(_taskID,TaskState.Created) registeredTaskOnly(_taskID)\n    {\n        require (msg.value >= tasks[_taskID].providerCollateral, \"Provider collateral is not enough\");\n        tasks[_taskID].activationTime = block.timestamp;\n        tasks[_taskID].providerCollateral = msg.value;\n        tasks[_taskID].taskState = TaskState.Active;\n        tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n        emit TaskActivated(_taskID);\n    }\n\n    // Complete\n    // TaskState -> Completed\n    // can be called only by provider when the computation is over\n\n    //called by docker container\n    function completeTask(bytes32 _taskID,string memory ver,  uint _duration, uint _timeReceivedProvider) public providerOnly(_taskID) inTaskState(_taskID,TaskState.Active) \n    {\n        tasks[_taskID].timeResultProvided = _timeReceivedProvider;\n        tasks[_taskID].duration = _duration;\n        if (InTime(_taskID) && CorrectVerification(_taskID, ver)){\n            tasks[_taskID].cost = tasks[_taskID].price * tasks[_taskID].duration;\n            tasks[_taskID].taskState = TaskState.CompletedSuccessfully;\n            tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n            emit TaskCompletedSuccessfully(_taskID);\n        }\n        else {\n            tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            performance[tasks[_taskID].provider].downVotes += 1;\n            emit ProviderDownvoted(tasks[_taskID].provider,_taskID);\n            tasks[_taskID].taskState = TaskState.CompletedUnsuccessfully;\n            tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n            emit TaskCompletedUnsuccessfully(_taskID);\n        }\n    }\n\n\n    //called by provider\n    function sendResults(bytes32 _taskID, string memory _results) public providerOnly(_taskID) inTaskState(_taskID,TaskState.CompletedSuccessfully) inPaymentState(_taskID,PaymentState.Initialized){\n        tasks[_taskID].timeResultReceived = block.timestamp;\n        tasks[_taskID].results = _results;\n        if (ProviderTime(_taskID)){\n            if (tasks[_taskID].cost <= tasks[_taskID].clientCollateral) {\n                tasks[_taskID].provider.transfer(tasks[_taskID].cost + tasks[_taskID].providerCollateral);\n                emit TransferMadeToProvider(tasks[_taskID].provider, tasks[_taskID].cost + tasks[_taskID].providerCollateral);\n                tasks[_taskID].client.transfer(tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n                emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n                tasks[_taskID].paymentState = PaymentState.Completed;\n                tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n                emit PaymentCompleted(_taskID);                \n            }\n            else {\n                tasks[_taskID].provider.transfer(tasks[_taskID].clientCollateral+tasks[_taskID].providerCollateral);\n                emit TransferMadeToProvider(tasks[_taskID].provider, tasks[_taskID].clientCollateral+tasks[_taskID].providerCollateral);\n                tasks[_taskID].paymentState = PaymentState.Pending;\n                tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n                emit PaymentPending(_taskID,tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n            }\n            tasks[_taskID].taskState = TaskState.ResultsReceivedSuccessfully;\n            tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n            emit TaskReceivedResultsSuccessfully(_taskID);\n            performance[tasks[_taskID].provider].upVotes += 1;\n            emit ProviderUpvoted(tasks[_taskID].provider,_taskID);\n        }\n        else {\n            tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            tasks[_taskID].taskState = TaskState.ResultsReceivedUnsuccessfully;\n            tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n            emit TaskReceivedResultsUnsuccessfully(_taskID);\n            performance[tasks[_taskID].provider].downVotes += 1;\n            emit ProviderDownvoted(tasks[_taskID].provider,_taskID);\n        }\n    }\n\n\n    function completePayment(bytes32 _taskID) public payable clientOnly(_taskID) inTaskState(_taskID,TaskState.ResultsReceivedSuccessfully) inPaymentState(_taskID,PaymentState.Pending) requiresValue(tasks[_taskID].cost - tasks[_taskID].clientCollateral) {\n        require (tasks[_taskID].paymentState == PaymentState.Pending, \"Payment not needed\");\n        tasks[_taskID].provider.transfer(msg.value);\n        emit TransferMadeToProvider(tasks[_taskID].provider, tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n        tasks[_taskID].paymentState = PaymentState.Completed;\n        tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n        emit PaymentCompleted(_taskID);\n    }\n\n    function setAuctionAddress(address _auctionAddress) public ownerOnly {\n        auctionAddress = _auctionAddress;\n    }\n\n    //add time difference between lastUpdateTimestamp and now\n    function deleteTasks() public ownerOnly { \n        for (uint i = bytes32_tasks.length; i > 0; i--)\n        {\n            bytes32 _taskID = bytes32_tasks[i-1];\n            if ((tasks[_taskID].taskState == TaskState.ResultsReceivedSuccessfully && tasks[_taskID].paymentState == PaymentState.Completed \n            || tasks[_taskID].taskState == TaskState.ResultsReceivedUnsuccessfully \n            || tasks[_taskID].taskState == TaskState.CompletedUnsuccessfully \n            || tasks[_taskID].taskState == TaskState.Cancelled \n            || tasks[_taskID].taskState == TaskState.Invalid) \n            && block.timestamp > tasks[_taskID].lastUpdateTimestamp + 60) \n            //TO ADD time difference between lastUpdateTimestamp eg 24h instead of 1 min\n            {\n                delete(tasks[_taskID]);\n                bytes32_tasks[i-1] = bytes32_tasks[bytes32_tasks.length - 1];\n                bytes32_tasks.pop();\n                emit TaskDeleted(_taskID);\n            }\n        }\n    }\n\n    function deleteTask(bytes32 _taskID) public ownerOnly registeredTaskOnly(_taskID) {\n        delete(tasks[_taskID]);\n        for (uint i=0; i < bytes32_tasks.length; i++)\n        {\n            if (bytes32_tasks[i] == _taskID)\n            {\n                bytes32_tasks[i] = bytes32_tasks[bytes32_tasks.length - 1];\n                bytes32_tasks.pop();\n                break;\n            }\n        }\n        emit TaskDeleted(_taskID);\n    }\n\n    function getActiveTasks() ownerOnly public view returns (uint256) {\n        return bytes32_tasks.length;\n    }\n    //Functions -> Private/internal\n    function InTime(bytes32 _taskID) private view returns (bool){\n        return (tasks[_taskID].timeResultProvided <= tasks[_taskID].activationTime + tasks[_taskID].deadline) && (tasks[_taskID].duration <= tasks[_taskID].deadline);  \n    }\n\n    function ProviderTime(bytes32 _taskID) private view returns (bool) {\n        return (tasks[_taskID].timeResultReceived <= tasks[_taskID].timeResultProvided + 600) && (tasks[_taskID].timeResultReceived >= tasks[_taskID].timeResultProvided) && (tasks[_taskID].timeResultReceived >= tasks[_taskID].activationTime + tasks[_taskID].duration) && (tasks[_taskID].timeResultProvided >= tasks[_taskID].activationTime + tasks[_taskID].duration); //gives 600 sec to provider to send the results, time received must be greater than time provided\n    }\n\n    function CorrectVerification(bytes32 _taskID, string memory ver) private view returns (bool){\n        return (tasks[_taskID].clientVerification == keccak256(abi.encodePacked(ver)));\n    }\n\n    function isRegistered(bytes32 _taskID) public view returns (bool) {\n        return (tasks[_taskID].client != address(0));\n    }\n\n    function getPerformance(address provider) public view returns (providerRating memory) {\n        return performance[provider];\n        // tuple: upVotes, downVotes\n    }\n\n    function getComputationCode(bytes32 _taskID) public view returns (string memory) {\n        return tasks[_taskID].computationCode;\n    }\n\n    function getVerificationCode(bytes32 _taskID) public view returns (string memory) {\n        return tasks[_taskID].verificationCode;\n    }\n\n    //Getters - some to be deleted\n    function getActivationTime(bytes32 _taskID) public view returns (uint)\n    {\n        return tasks[_taskID].activationTime;\n    }\n\n    function getLastUpdateTimestamp(bytes32 _taskID) public view returns (uint)\n    {\n        return tasks[_taskID].lastUpdateTimestamp;\n    }\n\n    function getResults(bytes32 _taskID) public clientOnly(_taskID) inTaskState(_taskID,TaskState.ResultsReceivedSuccessfully) inPaymentState(_taskID,PaymentState.Completed) view returns (string memory)  {\n        return tasks[_taskID].results;\n    }\n\n    function getTaskState(bytes32 _taskID) public clientOrProviderOnly(_taskID) view returns (string memory)\n    {\n        string memory ret = \"\";\n        if (tasks[_taskID].taskState == TaskState.Created) \n            ret = \"Created\";\n        else if (tasks[_taskID].taskState == TaskState.Cancelled)\n            ret = \"Cancelled\";\n        else if (tasks[_taskID].taskState == TaskState.Active)\n            ret = \"Active\";\n        else if (tasks[_taskID].taskState == TaskState.CompletedSuccessfully)\n            ret = \"CompletedSuccessfully\";\n        else if (tasks[_taskID].taskState == TaskState.CompletedUnsuccessfully)\n            ret = \"CompletedUnsuccessfully\";  \n        else if (tasks[_taskID].taskState == TaskState.Invalid)\n            ret = \"Invalid\";  \n        else if (tasks[_taskID].taskState == TaskState.ResultsReceivedSuccessfully)\n            ret = \"ResultsReceivedSuccessfully\";\n        else if (tasks[_taskID].taskState == TaskState.ResultsReceivedUnsuccessfully)\n            ret = \"ResultsReceivedUnsuccessfully\";\n        else \n            ret = \"Error\";\n        return ret; \n    }\n\n    function getPaymentState(bytes32 _taskID) public clientOrProviderOnly(_taskID) view returns (string memory)\n    {\n        string memory ret = \"\";\n        if (tasks[_taskID].paymentState == PaymentState.Initialized) \n            ret = \"Initialized\";\n        else if (tasks[_taskID].paymentState == PaymentState.Pending) \n            ret = \"Pending\";\n        else if (tasks[_taskID].paymentState == PaymentState.Completed) \n            ret = \"Completed\";\n        else \n            ret = \"Error\";  \n        return ret; \n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    function getAuctionAddress() public view returns (address) {\n        return auctionAddress;\n    }\n\n    function getTask(bytes32 _taskID) public view returns (Task memory) {\n        return tasks[_taskID];\n    }\n\n    // Fallback Function\n    fallback() external payable{\n        revert();\n    }\n\n    receive() external payable {\n        revert(\"bad call\");\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}