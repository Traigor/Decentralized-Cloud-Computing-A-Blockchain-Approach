{
  "language": "Solidity",
  "sources": {
    "contracts/TasksManager_GasTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract TasksManagerGasTest {\n\n    address private immutable owner; \n\n    enum TaskState {\n        Created,\n        Cancelled, \n        Active,\n        CompletedSuccessfully,\n        CompletedUnsuccessfully,\n        Invalid, \n        ResultsReceivedSuccessfully,\n        ResultsReceivedUnsuccessfully\n    }\n\n    enum PaymentState {\n        Initialized,\n        Pending,\n        Completed \n    }\n\n    struct Task {\n        address payable client; \n        address payable provider;\n        uint providerCollateral;\n        uint clientCollateral; \n        uint deadline;\n        uint price;\n        uint duration;\n        uint cost;       \n        uint activationTime;\n        uint timeResultProvided;\n        uint timeResultReceived;\n        string computationCode;\n        string verificationCode;\n        string results;\n        bytes32 clientVerification;\n        uint lastUpdateTimestamp;\n        TaskState taskState;\n        PaymentState paymentState;\n    }\n\n    struct providerRating {\n        uint upVotes;\n        uint downVotes;\n    }\n\n    mapping (bytes32 => Task) private tasks;\n    bytes32[] public bytes32_tasks;\n    mapping(address => providerRating) private performance;\n\n    //Events\n    event TaskCreated(bytes32 taskID);\n    event TaskActivated(bytes32 taskID);\n    event TaskCompletedSuccessfully(bytes32 taskID);\n    event TaskCompletedUnsuccessfully(bytes32 taskID);\n    event TaskReceivedResultsSuccessfully(bytes32 taskID);\n    event TaskReceivedResultsUnsuccessfully(bytes32 taskID);\n    event TaskCancelled(bytes32 taskID);\n    event TaskInvalidated(bytes32 taskID);\n    event PaymentPending(bytes32 taskID, uint payment);\n    event PaymentCompleted(bytes32 taskID);\n    event TransferMadeToClient(address client, uint amount);\n    event TransferMadeToProvider(address provider, uint amount);\n    event ProviderUpvoted(address provider, bytes32 taskID);\n    event ProviderDownvoted(address provider, bytes32 taskID);\n    event TaskDeleted(bytes32 taskID);\n\n    //Modifiers\n\n    error Error__OwnerOnly();\n    error Error__ClientOnly();\n    error Error__ProviderOnly();\n    error Error__ClientOrProviderOnly();\n    error Error__TaskState();\n    error Error__PaymentState();\n    error Error__WrongValue();\n    error Error__RegisteredTaskOnly();\n    error Error__NotRegisteredTaskOnly();\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    //called by client, client = msg.sender\n    function createTask(\n        bytes32 _taskID, \n        address payable _provider,\n        uint _price,\n        uint _deadline,\n        bytes32 _clientVerification,\n        string memory _verificationCode,\n        string memory _computationCode\n    ) public payable \n    {\n        if(isRegistered(_taskID))\n        {\n            revert Error__NotRegisteredTaskOnly();\n        }\n        require (msg.value >= _price * 2, \"Client collateral is not enough\");\n        tasks[_taskID].client = payable (msg.sender);\n        tasks[_taskID].clientCollateral = msg.value;\n        tasks[_taskID].provider = _provider;\n        tasks[_taskID].providerCollateral = _price * 10;\n        tasks[_taskID].price = _price;\n        tasks[_taskID].deadline = _deadline;\n        tasks[_taskID].clientVerification = _clientVerification;\n        tasks[_taskID].verificationCode = _verificationCode;\n        tasks[_taskID].computationCode = _computationCode;\n        tasks[_taskID].taskState = TaskState.Created;\n        tasks[_taskID].paymentState = PaymentState.Initialized;\n        tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n        bytes32_tasks.push(_taskID);\n        emit TaskCreated(_taskID);\n    }\n\n    //Cancel\n    //TaskState -> Cancel\n    //refunds payment to client\n    //can be called only by client and only if contract hasnt been activated by provider\n\n    function cancelTask(bytes32 _taskID) public  \n    {\n        if (msg.sender != tasks[_taskID].client)\n        {\n            revert Error__ClientOnly();\n        }\n        if (tasks[_taskID].taskState != TaskState.Created) \n        {\n            revert Error__TaskState();\n        }\n        tasks[_taskID].taskState = TaskState.Cancelled;\n        tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral);\n        tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n        emit TransferMadeToClient(tasks[_taskID].client,tasks[_taskID].clientCollateral);\n        emit TaskCancelled(_taskID);\n        // deleteTask(_taskID);\n    }\n\n    function invalidateTask(bytes32 _taskID) public\n    {\n        if (msg.sender != tasks[_taskID].client)\n        {\n            revert Error__ClientOnly();\n        }\n        if (tasks[_taskID].taskState != TaskState.Active) \n        {\n            revert Error__TaskState();\n        }\n        require(\n            (block.timestamp > tasks[_taskID].activationTime + tasks[_taskID].deadline),\n            \"Time has not expired.\"\n        );\n        tasks[_taskID].taskState = TaskState.Invalid;\n  \n        tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n        tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n        emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n        emit TaskInvalidated(_taskID);\n        // deleteTask(_taskID);\n    }\n\n    // Activate\n    // TaskState -> Activated\n    // can be called only by provider to start the process\n\n    function activateTask(bytes32 _taskID) public payable\n    {\n        if (msg.sender != tasks[_taskID].provider)\n        {\n            revert Error__ProviderOnly();\n        }\n        if (tasks[_taskID].taskState != TaskState.Created) \n        {\n            revert Error__TaskState();\n        }\n        if (!isRegistered(_taskID)) \n        {\n            revert Error__RegisteredTaskOnly();\n        }\n        require (msg.value >= tasks[_taskID].providerCollateral, \"Provider collateral is not enough\");\n        tasks[_taskID].activationTime = block.timestamp;\n        tasks[_taskID].providerCollateral = msg.value;\n        tasks[_taskID].taskState = TaskState.Active;\n        tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n        emit TaskActivated(_taskID);\n    }\n\n    // Complete\n    // TaskState -> Completed\n    // can be called only by provider when the computation is over\n\n    //called by docker container\n    function completeTask(bytes32 _taskID,string memory ver,  uint _duration, uint _timeReceivedProvider) public\n    {\n        if (msg.sender != tasks[_taskID].provider)\n        {\n            revert Error__ProviderOnly();\n        }\n        if (tasks[_taskID].taskState != TaskState.Active) \n        {\n            revert Error__TaskState();\n        }\n        tasks[_taskID].timeResultProvided = _timeReceivedProvider;\n        tasks[_taskID].duration = _duration;\n        if (InTime(_taskID) && CorrectVerification(_taskID, ver)){\n            tasks[_taskID].cost = tasks[_taskID].price * tasks[_taskID].duration;\n            tasks[_taskID].taskState = TaskState.CompletedSuccessfully;\n            tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n            emit TaskCompletedSuccessfully(_taskID);\n        }\n        else {\n            tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            performance[tasks[_taskID].provider].downVotes += 1;\n            emit ProviderDownvoted(tasks[_taskID].provider,_taskID);\n            tasks[_taskID].taskState = TaskState.CompletedUnsuccessfully;\n            tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n            emit TaskCompletedUnsuccessfully(_taskID);\n        }\n    }\n\n\n    //called by provider\n    function sendResults(bytes32 _taskID, string memory _results) public {\n        if (msg.sender != tasks[_taskID].provider)\n        {\n            revert Error__ProviderOnly();\n        }\n        if (tasks[_taskID].taskState != TaskState.CompletedSuccessfully) \n        {\n            revert Error__TaskState();\n        }\n        if (tasks[_taskID].paymentState != PaymentState.Initialized) \n        {\n            revert Error__PaymentState();\n        }\n        tasks[_taskID].timeResultReceived = block.timestamp;\n        tasks[_taskID].results = _results;\n        if (ProviderTime(_taskID)){\n            if (tasks[_taskID].cost <= tasks[_taskID].clientCollateral) {\n                tasks[_taskID].provider.transfer(tasks[_taskID].cost + tasks[_taskID].providerCollateral);\n                emit TransferMadeToProvider(tasks[_taskID].provider, tasks[_taskID].cost + tasks[_taskID].providerCollateral);\n                tasks[_taskID].client.transfer(tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n                emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n                tasks[_taskID].paymentState = PaymentState.Completed;\n                tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n                emit PaymentCompleted(_taskID);                \n            }\n            else {\n                tasks[_taskID].provider.transfer(tasks[_taskID].clientCollateral+tasks[_taskID].providerCollateral);\n                emit TransferMadeToProvider(tasks[_taskID].provider, tasks[_taskID].clientCollateral+tasks[_taskID].providerCollateral);\n                tasks[_taskID].paymentState = PaymentState.Pending;\n                tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n                emit PaymentPending(_taskID,tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n            }\n            tasks[_taskID].taskState = TaskState.ResultsReceivedSuccessfully;\n            tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n            emit TaskReceivedResultsSuccessfully(_taskID);\n            performance[tasks[_taskID].provider].upVotes += 1;\n            emit ProviderUpvoted(tasks[_taskID].provider,_taskID);\n        }\n        else {\n            tasks[_taskID].client.transfer(tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            emit TransferMadeToClient(tasks[_taskID].client, tasks[_taskID].clientCollateral + tasks[_taskID].providerCollateral);\n            tasks[_taskID].taskState = TaskState.ResultsReceivedUnsuccessfully;\n            tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n            emit TaskReceivedResultsUnsuccessfully(_taskID);\n            performance[tasks[_taskID].provider].downVotes += 1;\n            emit ProviderDownvoted(tasks[_taskID].provider,_taskID);\n        }\n    }\n\n\n    function completePayment(bytes32 _taskID) public payable {\n        if (msg.sender != tasks[_taskID].client)\n        {\n            revert Error__ClientOnly();\n        }\n        if (tasks[_taskID].taskState != TaskState.ResultsReceivedSuccessfully) \n        {\n            revert Error__TaskState();\n        }\n         if (tasks[_taskID].paymentState != PaymentState.Pending) \n        {\n            revert Error__PaymentState();\n        }\n        if (msg.value != tasks[_taskID].cost - tasks[_taskID].clientCollateral)\n        {\n            revert Error__WrongValue();\n        }\n        require (tasks[_taskID].paymentState == PaymentState.Pending, \"Payment not needed\");\n        tasks[_taskID].provider.transfer(msg.value);\n        emit TransferMadeToProvider(tasks[_taskID].provider, tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n        tasks[_taskID].paymentState = PaymentState.Completed;\n        tasks[_taskID].lastUpdateTimestamp = block.timestamp;\n        emit PaymentCompleted(_taskID);\n    }\n\n    //add time difference between lastUpdateTimestamp and now\n    function deleteTasks() public { \n        if (msg.sender != owner)\n        {\n            revert Error__OwnerOnly();\n        }\n        for (uint i = bytes32_tasks.length; i > 0; i--)\n        {\n            bytes32 _taskID = bytes32_tasks[i-1];\n            if ((tasks[_taskID].taskState == TaskState.ResultsReceivedSuccessfully && tasks[_taskID].paymentState == PaymentState.Completed \n            || tasks[_taskID].taskState == TaskState.ResultsReceivedUnsuccessfully \n            || tasks[_taskID].taskState == TaskState.CompletedUnsuccessfully \n            || tasks[_taskID].taskState == TaskState.Cancelled \n            || tasks[_taskID].taskState == TaskState.Invalid) \n            && block.timestamp > tasks[_taskID].lastUpdateTimestamp + 60) \n            //TO ADD time difference between lastUpdateTimestamp eg 24h instead of 1 min\n            {\n                delete(tasks[_taskID]);\n                bytes32_tasks[i-1] = bytes32_tasks[bytes32_tasks.length - 1];\n                bytes32_tasks.pop();\n                emit TaskDeleted(_taskID);\n            }\n        }\n    }\n\n    function deleteTask(bytes32 _taskID) public  {\n        if (msg.sender != owner)\n        {\n            revert Error__OwnerOnly();\n        }\n        if (!isRegistered(_taskID)) \n        {\n            revert Error__RegisteredTaskOnly();\n        }\n        delete(tasks[_taskID]);\n        for (uint i=0; i < bytes32_tasks.length; i++)\n        {\n            if (bytes32_tasks[i] == _taskID)\n            {\n                bytes32_tasks[i] = bytes32_tasks[bytes32_tasks.length - 1];\n                bytes32_tasks.pop();\n                break;\n            }\n        }\n        emit TaskDeleted(_taskID);\n    }\n\n    function getActiveTasks() public view returns (uint256) {\n        if (msg.sender != owner)\n        {\n            revert Error__OwnerOnly();\n        }\n        return bytes32_tasks.length;\n    }\n    //Functions -> Private/internal\n    function InTime(bytes32 _taskID) private view returns (bool){\n        return (tasks[_taskID].timeResultProvided <= tasks[_taskID].activationTime + tasks[_taskID].deadline) && (tasks[_taskID].duration <= tasks[_taskID].deadline);  \n    }\n\n    function ProviderTime(bytes32 _taskID) private view returns (bool) {\n        return (tasks[_taskID].timeResultReceived <= tasks[_taskID].timeResultProvided + 600) && (tasks[_taskID].timeResultReceived >= tasks[_taskID].timeResultProvided) && (tasks[_taskID].timeResultReceived >= tasks[_taskID].activationTime + tasks[_taskID].duration) && (tasks[_taskID].timeResultProvided >= tasks[_taskID].activationTime + tasks[_taskID].duration); //gives 600 sec to provider to send the results, time received must be greater than time provided\n    }\n\n    function CorrectVerification(bytes32 _taskID, string memory ver) private view returns (bool){\n        return (tasks[_taskID].clientVerification == keccak256(abi.encodePacked(ver)));\n    }\n\n    function isRegistered(bytes32 _taskID) public view returns (bool) {\n        return (tasks[_taskID].client != address(0));\n    }\n\n    function getPerformance(address provider) public view returns (providerRating memory) {\n        return performance[provider];\n        // tuple: upVotes, downVotes\n    }\n\n    function getComputationCode(bytes32 _taskID) public view returns (string memory) {\n        return tasks[_taskID].computationCode;\n    }\n\n    function getVerificationCode(bytes32 _taskID) public view returns (string memory) {\n        return tasks[_taskID].verificationCode;\n    }\n\n    //Getters - some to be deleted\n    function getActivationTime(bytes32 _taskID) public view returns (uint)\n    {\n        return tasks[_taskID].activationTime;\n    }\n\n    function getLastUpdateTimestamp(bytes32 _taskID) public view returns (uint)\n    {\n        return tasks[_taskID].lastUpdateTimestamp;\n    }\n\n    function getResults(bytes32 _taskID) public view returns (string memory)  {\n        if (msg.sender != tasks[_taskID].client)\n        {\n            revert Error__ClientOnly();\n        }\n        if (tasks[_taskID].taskState != TaskState.ResultsReceivedSuccessfully) \n        {\n            revert Error__TaskState();\n        }\n         if (tasks[_taskID].paymentState != PaymentState.Completed) \n        {\n            revert Error__PaymentState();\n        }\n        return tasks[_taskID].results;\n    }\n\n    function getTaskState(bytes32 _taskID) public view returns (string memory)\n    {\n        if (msg.sender != tasks[_taskID].client && msg.sender != tasks[_taskID].provider && msg.sender != owner)\n        {\n            revert Error__ClientOrProviderOnly();\n        }\n        string memory ret = \"\";\n        if (tasks[_taskID].taskState == TaskState.Created) \n            ret = \"Created\";\n        else if (tasks[_taskID].taskState == TaskState.Cancelled)\n            ret = \"Cancelled\";\n        else if (tasks[_taskID].taskState == TaskState.Active)\n            ret = \"Active\";\n        else if (tasks[_taskID].taskState == TaskState.CompletedSuccessfully)\n            ret = \"CompletedSuccessfully\";\n        else if (tasks[_taskID].taskState == TaskState.CompletedUnsuccessfully)\n            ret = \"CompletedUnsuccessfully\";  \n        else if (tasks[_taskID].taskState == TaskState.Invalid)\n            ret = \"Invalid\";  \n        else if (tasks[_taskID].taskState == TaskState.ResultsReceivedSuccessfully)\n            ret = \"ResultsReceivedSuccessfully\";\n        else if (tasks[_taskID].taskState == TaskState.ResultsReceivedUnsuccessfully)\n            ret = \"ResultsReceivedUnsuccessfully\";\n        else \n            ret = \"Error\";\n        return ret; \n    }\n\n    function getPaymentState(bytes32 _taskID) public view returns (string memory)\n    {\n        if (msg.sender != tasks[_taskID].client && msg.sender != tasks[_taskID].provider && msg.sender != owner)\n        {\n            revert Error__ClientOrProviderOnly();\n        }\n        string memory ret = \"\";\n        if (tasks[_taskID].paymentState == PaymentState.Initialized) \n            ret = \"Initialized\";\n        else if (tasks[_taskID].paymentState == PaymentState.Pending) \n            ret = \"Pending\";\n        else if (tasks[_taskID].paymentState == PaymentState.Completed) \n            ret = \"Completed\";\n        else \n            ret = \"Error\";  \n        return ret; \n    }\n\n    function getCost(bytes32 _taskID) public view returns (uint)\n    {\n        if (msg.sender != tasks[_taskID].client && msg.sender != tasks[_taskID].provider && msg.sender != owner)\n        {\n            revert Error__ClientOrProviderOnly();\n        }\n        return tasks[_taskID].cost;\n    }\n\n    function getPayment(bytes32 _taskID) public view returns (uint) \n    {\n        if (msg.sender != tasks[_taskID].client && msg.sender != tasks[_taskID].provider && msg.sender != owner)\n        {\n            revert Error__ClientOrProviderOnly();\n        }\n        if (tasks[_taskID].cost > tasks[_taskID].clientCollateral) {\n            return (tasks[_taskID].cost - tasks[_taskID].clientCollateral);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    function getTask(bytes32 _taskID) public view returns (Task memory) {\n        if (msg.sender != owner)\n        {\n            revert Error__OwnerOnly();\n        }\n        return tasks[_taskID];\n    }\n\n    // Fallback Function\n    fallback() external payable{\n        revert();\n    }\n\n    receive() external payable {\n        revert(\"bad call\");\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}